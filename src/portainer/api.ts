/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface AuthAuthenticatePayload {
  /**
   * Password
   * @example "mypassword"
   */
  password: string;
  /**
   * Username
   * @example "admin"
   */
  username: string;
}

export interface AuthAuthenticateResponse {
  /**
   * JWT token used to authenticate against the API
   * @example "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE"
   */
  jwt?: string;
}

export interface AuthOauthPayload {
  /** OAuth code returned from OAuth Provided */
  code?: string;
}

export interface BackupBackupPayload {
  password?: string;
}

export interface BackupBackupStatus {
  failed?: boolean;
  timestampUTC?: string;
}

export interface BackupRestorePayload {
  /** Content of the backup */
  fileContent: number[];
  /** File name */
  fileName: string;
  /** Password to decrypt the backup with */
  password?: string;
}

export interface BackupRestoreS3Settings {
  /** AWS access key id */
  accessKeyID?: string;
  /** AWS S3 bucket name */
  bucketName?: string;
  /** AWS S3 filename in the bucket */
  filename?: string;
  password?: string;
  /**
   * AWS S3 region. Default to "us-east-1"
   * @example "us-east-1"
   */
  region?: string;
  /** S3 compatible host */
  s3CompatibleHost?: string;
  /** AWS secret access key */
  secretAccessKey?: string;
}

export interface BackupS3BackupPayload {
  /** AWS access key id */
  accessKeyID?: string;
  /** AWS S3 bucket name */
  bucketName?: string;
  /** Crontab rule to make periodical backups */
  cronRule?: string;
  /** Password to encrypt the backup with */
  password?: string;
  /**
   * AWS S3 region. Default to "us-east-1"
   * @example "us-east-1"
   */
  region?: string;
  /** S3 compatible host */
  s3CompatibleHost?: string;
  /** AWS secret access key */
  secretAccessKey?: string;
}

export interface ChatChatQueryPayload {
  /**
   * Context is used to build a context that will be added to the prompt sent to OpenAI.
   * Only accepts a list of specific values:
   * environment_aware will create a context based on environment information (EnvironmentID parameter is mandatory).
   * @example "environment_aware"
   */
  context: string;
  /**
   * EnvironmentID is the ID of the environment for which the chat query is being made
   * it will be used to retrieve context information about the environment and pass it to then OpenAI API.
   * Mandatory when environment_aware context is used.
   * @example 1
   */
  environmentID?: number;
  /**
   * Message is the message that will be forwarded to the OpenAI API.
   * @example "I would like to deploy a wordpress production setup"
   */
  message: string;
  /**
   * Model is the name of the OpenAI model that will be used to generate the response.
   * Only accepts a list of specific values: text-davinci-003, gpt-3.5-turbo, gpt-4
   * Note that the use of the GPT-4 model requires access to its API.
   * Optional: will default to gpt-3.5-turbo if not provided.
   * @example "gpt-3.5-turbo"
   */
  model?: string;
}

export interface ChatChatQueryResponse {
  /** Message is the message that is returned by the OpenAI API. */
  message?: string;
  /** Yaml is the content of the compose / kubernetes manifest file that was generated by the OpenAI API as part of the response. */
  yaml?: string;
}

export interface ContainersContainerGpusResponse {
  gpus?: string;
}

export interface CustomtemplatesCustomTemplateFromFileContentPayload {
  /**
   * Description of the template
   * @example "High performance web server"
   */
  description: string;
  /** Content of stack file */
  fileContent: string;
  /**
   * URL of the template's logo
   * @example "https://cloudinovasi.id/assets/img/logos/nginx.png"
   */
  logo?: string;
  /**
   * A note that will be displayed in the UI. Supports HTML content
   * @example "This is my <b>custom</b> template"
   */
  note?: string;
  /**
   * Platform associated to the template.
   * Valid values are: 1 - 'linux', 2 - 'windows'
   * Required for Docker stacks
   * @example 1
   */
  platform?: 1 | 2;
  /**
   * Title of the template
   * @example "Nginx"
   */
  title: string;
  /**
   * Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
   * @example 1
   */
  type: 1 | 2 | 3;
  /** Definitions of variables in the stack file */
  variables?: PortainereeCustomTemplateVariableDefinition[];
}

export interface CustomtemplatesCustomTemplateFromGitRepositoryPayload {
  /**
   * Path to the Stack file inside the Git repository
   * @default "docker-compose.yml"
   * @example "docker-compose.yml"
   */
  composeFilePathInRepository?: string;
  /**
   * Description of the template
   * @example "High performance web server"
   */
  description: string;
  /**
   * URL of the template's logo
   * @example "https://cloudinovasi.id/assets/img/logos/nginx.png"
   */
  logo?: string;
  /**
   * A note that will be displayed in the UI. Supports HTML content
   * @example "This is my <b>custom</b> template"
   */
  note?: string;
  /**
   * Platform associated to the template.
   * Valid values are: 1 - 'linux', 2 - 'windows'
   * Required for Docker stacks
   * @example 1
   */
  platform?: 1 | 2;
  /**
   * Use basic authentication to clone the Git repository
   * @example true
   */
  repositoryAuthentication?: boolean;
  /**
   * GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication
   * is true and RepositoryUsername/RepositoryPassword are not provided
   * @example 0
   */
  repositoryGitCredentialID?: number;
  /**
   * Password used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitPassword"
   */
  repositoryPassword?: string;
  /**
   * Reference name of a Git repository hosting the Stack file
   * @example "refs/heads/master"
   */
  repositoryReferenceName?: string;
  /**
   * URL of a Git repository hosting the Stack file
   * @example "https://github.com/openfaas/faas"
   */
  repositoryURL: string;
  /**
   * Username used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitUsername"
   */
  repositoryUsername?: string;
  /**
   * Title of the template
   * @example "Nginx"
   */
  title: string;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
  /**
   * Type of created stack (1 - swarm, 2 - compose)
   * @example 1
   */
  type: 1 | 2;
  /** Definitions of variables in the stack file */
  variables?: PortainereeCustomTemplateVariableDefinition[];
}

export interface CustomtemplatesCustomTemplateUpdatePayload {
  /**
   * Description of the template
   * @example "High performance web server"
   */
  description: string;
  /** Content of stack file */
  fileContent: string;
  /**
   * URL of the template's logo
   * @example "https://cloudinovasi.id/assets/img/logos/nginx.png"
   */
  logo?: string;
  /**
   * A note that will be displayed in the UI. Supports HTML content
   * @example "This is my <b>custom</b> template"
   */
  note?: string;
  /**
   * Platform associated to the template.
   * Valid values are: 1 - 'linux', 2 - 'windows'
   * Required for Docker stacks
   * @example 1
   */
  platform?: 1 | 2;
  /**
   * Title of the template
   * @example "Nginx"
   */
  title: string;
  /**
   * Type of created stack (1 - swarm, 2 - compose, 3 - kubernetes)
   * @example 1
   */
  type: 1 | 2 | 3;
  /** Definitions of variables in the stack file */
  variables?: PortainereeCustomTemplateVariableDefinition[];
}

export interface CustomtemplatesFileResponse {
  fileContent?: string;
}

export interface EdgegroupsDecoratedEdgeGroup {
  Dynamic?: boolean;
  Endpoints?: number[];
  HasEdgeGroup?: boolean;
  HasEdgeStack?: boolean;
  /**
   * EdgeGroup Identifier
   * @example 1
   */
  Id?: number;
  Name?: string;
  PartialMatch?: boolean;
  TagIds?: number[];
  endpointTypes?: number[];
}

export interface EdgegroupsEdgeGroupCreatePayload {
  dynamic?: boolean;
  endpoints?: number[];
  name?: string;
  partialMatch?: boolean;
  tagIDs?: number[];
}

export interface EdgegroupsEdgeGroupUpdatePayload {
  dynamic?: boolean;
  endpoints?: number[];
  name?: string;
  partialMatch?: boolean;
  tagIDs?: number[];
}

export interface EdgejobsEdgeJobCreateFromFileContentPayload {
  cronExpression?: string;
  edgeGroups?: number[];
  endpoints?: number[];
  fileContent?: string;
  name?: string;
  recurring?: boolean;
}

export interface EdgejobsEdgeJobCreateFromFilePayload {
  cronExpression?: string;
  edgeGroups?: number[];
  endpoints?: number[];
  file?: number[];
  name?: string;
  recurring?: boolean;
}

export interface EdgejobsEdgeJobFileResponse {
  FileContent?: string;
}

export interface EdgejobsEdgeJobUpdatePayload {
  cronExpression?: string;
  edgeGroups?: number[];
  endpoints?: number[];
  fileContent?: string;
  name?: string;
  recurring?: boolean;
}

export interface EdgejobsFileResponse {
  FileContent?: string;
}

export interface EdgejobsTaskContainer {
  EndpointId?: number;
  Id?: string;
  LogsStatus?: number;
}

export interface EdgestacksStackFileResponse {
  StackFileContent?: string;
}

export interface EdgestacksSwarmStackFromFileContentPayload {
  /**
   * Deployment type to deploy this stack
   * Valid values are: 0 - 'compose', 1 - 'kubernetes', 2 - 'nomad'
   * for compose stacks will use kompose to convert to kubernetes manifest for kubernetes environments(endpoints)
   * kubernetes deploy type is enabled only for kubernetes environments(endpoints)
   * nomad deploy type is enabled only for nomad environments(endpoints)
   * @example 0
   */
  deploymentType?: 0 | 1 | 2;
  /**
   * List of identifiers of EdgeGroups
   * @example [1]
   */
  edgeGroups?: number[];
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Pre Pull image
   * @example false
   */
  prePullImage?: boolean;
  /** List of Registries to use for this stack */
  registries?: number[];
  /**
   * Retry deploy
   * @example false
   */
  retryDeploy?: boolean;
  /**
   * Content of the Stack file
   * @example "version: 3
   *  services:
   *  web:
   *  image:nginx"
   */
  stackFileContent: string;
  /** Uses the manifest's namespaces instead of the default one */
  useManifestNamespaces?: boolean;
}

export interface EdgestacksSwarmStackFromFileUploadPayload {
  /**
   * Deployment type to deploy this stack
   * Valid values are: 0 - 'compose', 1 - 'kubernetes', 2 - 'nomad'
   * for compose stacks will use kompose to convert to kubernetes manifest for kubernetes environments(endpoints)
   * kubernetes deploytype is enabled only for kubernetes environments(endpoints)
   * nomad deploytype is enabled only for nomad environments(endpoints)
   * @example 0
   */
  deploymentType?: 0 | 1 | 2;
  edgeGroups?: number[];
  name?: string;
  /**
   * Pre Pull image
   * @example false
   */
  prePullImage?: boolean;
  registries?: number[];
  /**
   * Retry deploy
   * @example false
   */
  retryDeploy?: boolean;
  stackFileContent?: number[];
  /** Uses the manifest's namespaces instead of the default one */
  useManifestNamespaces?: boolean;
}

export interface EdgestacksSwarmStackFromGitRepositoryPayload {
  /**
   * Deployment type to deploy this stack
   * Valid values are: 0 - 'compose', 1 - 'kubernetes', 2 - 'nomad'
   * for compose stacks will use kompose to convert to kubernetes manifest for kubernetes environments(endpoints)
   * kubernetes deploy type is enabled only for kubernetes environments(endpoints)
   * nomad deploy type is enabled only for nomad environments(endpoints)
   * @example 0
   */
  deploymentType?: 0 | 1 | 2;
  /**
   * List of identifiers of EdgeGroups
   * @example [1]
   */
  edgeGroups?: number[];
  /**
   * Path to the Stack file inside the Git repository
   * @default "docker-compose.yml"
   * @example "docker-compose.yml"
   */
  filePathInRepository?: string;
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Pre Pull image
   * @example false
   */
  prePullImage?: boolean;
  /** List of Registries to use for this stack */
  registries?: number[];
  /**
   * Use basic authentication to clone the Git repository
   * @example true
   */
  repositoryAuthentication?: boolean;
  /**
   * GitCredentialID used to identify the binded git credential
   * @example 0
   */
  repositoryGitCredentialID?: number;
  /**
   * Password used in basic authentication. Required when RepositoryAuthentication is true.
   * @example "myGitPassword"
   */
  repositoryPassword?: string;
  /**
   * Reference name of a Git repository hosting the Stack file
   * @example "refs/heads/master"
   */
  repositoryReferenceName?: string;
  /**
   * URL of a Git repository hosting the Stack file
   * @example "https://github.com/openfaas/faas"
   */
  repositoryURL: string;
  /**
   * Username used in basic authentication. Required when RepositoryAuthentication is true.
   * @example "myGitUsername"
   */
  repositoryUsername?: string;
  /**
   * Retry deploy
   * @example false
   */
  retryDeploy?: boolean;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
  /** Uses the manifest's namespaces instead of the default one */
  useManifestNamespaces?: boolean;
}

export interface EdgestacksUpdateEdgeStackPayload {
  /**
   * Deployment type to deploy this stack
   * Valid values are: 0 - 'compose', 1 - 'kubernetes', 2 - 'nomad'
   * for compose stacks will use kompose to convert to kubernetes manifest for kubernetes environments(endpoints)
   * kubernetes deploy type is enabled only for kubernetes environments(endpoints)
   * nomad deploy type is enabled only for nomad environments(endpoints)
   */
  deploymentType?: number;
  edgeGroups?: number[];
  prePullImage?: boolean;
  rePullImage?: boolean;
  registries?: number[];
  retryDeploy?: boolean;
  stackFileContent?: string;
  /** Uses the manifest's namespaces instead of the default one */
  useManifestNamespaces?: boolean;
  version?: number;
}

export interface EdgeupdateschedulesActiveSchedulePayload {
  environmentIDs?: number[];
}

export interface EdgeupdateschedulesCreatePayload {
  groupIDs?: number[];
  name?: string;
  registryID?: number;
  scheduledTime?: string;
  type?: number;
  version?: string;
}

export interface EdgeupdateschedulesDecoratedUpdateSchedule {
  /**
   * Created timestamp
   * @example 1564897200
   */
  created?: number;
  /**
   * Created by user id
   * @example 1
   */
  createdBy?: number;
  edgeGroupIds?: number[];
  /**
   * EdgeStack Identifier
   * @example 1
   */
  edgeStackId?: number;
  environmentsPreviousVersions?: Record<string, string>;
  /**
   * EdgeUpdateSchedule Identifier
   * @example 1
   */
  id?: number;
  /**
   * Name of the schedule
   * @example "Update Schedule"
   */
  name?: string;
  /**
   * ID of registry
   * @example 1
   */
  registryId?: number;
  scheduledTime?: string;
  status?: number;
  statusMessage?: string;
  /**
   * Type of the update (1 - update, 2 - rollback)
   * @example 1
   */
  type?: 1 | 2;
  /** @example "1.0.0" */
  version?: string;
}

export interface EdgeupdateschedulesUpdatePayload {
  groupIDs?: number[];
  name?: string;
  /**
   * ID of registry
   * @example 1
   */
  registryID?: number;
  scheduledTime?: string;
  /**
   * Type of the update (1 - update, 2 - rollback)
   * @example 1
   */
  type?: 1 | 2;
  version?: string;
}

export interface EndpointedgeEdgeAsyncResponse {
  commandInterval?: number;
  commands?: PortainereeEdgeAsyncCommand[];
  endpointID?: number;
  needFullSnapshot?: boolean;
  pingInterval?: number;
  snapshotInterval?: number;
}

export interface EndpointedgeConfigResponse {
  edgeUpdateID?: number;
  name?: string;
  /** Namespace to use for Kubernetes manifests, leave empty to use the namespaces defined in the manifest */
  namespace?: string;
  prePullImage?: boolean;
  rePullImage?: boolean;
  registryCredentials?: PortainereeEdgeRegistryCredential[];
  retryDeploy?: boolean;
  stackFileContent?: string;
}

export interface EndpointedgeEdgeJobResponse {
  /**
   * Whether to collect logs
   * @example true
   */
  CollectLogs?: boolean;
  /**
   * A cron expression to schedule this job
   * @example "* * * * *"
   */
  CronExpression?: string;
  /**
   * EdgeJob Identifier
   * @example 2
   */
  Id?: number;
  /**
   * Script to run
   * @example "echo hello"
   */
  Script?: string;
  /**
   * Version of this EdgeJob
   * @example 2
   */
  Version?: number;
}

export interface EndpointedgeEndpointEdgeStatusInspectResponse {
  /**
   * The current value of CheckinInterval
   * @example 5
   */
  checkin?: number;
  credentials?: string;
  /**
   * The tunnel port
   * @example 8732
   */
  port?: number;
  /** List of requests for jobs to run on the environment(endpoint) */
  schedules?: EndpointedgeEdgeJobResponse[];
  /** List of stacks to be deployed on the environments(endpoints) */
  stacks?: EndpointedgeStackStatusResponse[];
  /**
   * Status represents the environment(endpoint) status
   * @example "REQUIRED"
   */
  status?: string;
}

export interface EndpointedgeGenerateKeyResponse {
  edgeKey?: string;
}

export interface EndpointedgeStackStatusResponse {
  /**
   * EdgeStack Identifier
   * @example 1
   */
  id?: number;
  /**
   * Version of this stack
   * @example 3
   */
  version?: number;
}

export interface EndpointgroupsEndpointGroupCreatePayload {
  /**
   * List of environment(endpoint) identifiers that will be part of this group
   * @example [1,3]
   */
  associatedEndpoints?: number[];
  /**
   * Environment(Endpoint) group description
   * @example "description"
   */
  description?: string;
  /**
   * Environment(Endpoint) group name
   * @example "my-Environment-group"
   */
  name: string;
  /**
   * List of tag identifiers to which this environment(endpoint) group is associated
   * @example [1,2]
   */
  tagIDs?: number[];
}

export interface EndpointgroupsEndpointGroupUpdatePayload {
  /**
   * Environment(Endpoint) group description
   * @example "description"
   */
  description?: string;
  /**
   * Environment(Endpoint) group name
   * @example "my-environment-group"
   */
  name?: string;
  /**
   * List of tag identifiers associated to the environment(endpoint) group
   * @example [3,4]
   */
  tagIDs?: number[];
  teamAccessPolicies?: PortainereeTeamAccessPolicies;
  userAccessPolicies?: PortainereeUserAccessPolicies;
}

export interface EndpointsDockerhubStatusResponse {
  /** Daily limit */
  limit?: number;
  /** Remaiming images to pull */
  remaining?: number;
}

export interface EndpointsEndpointCreateGlobalKeyResponse {
  /** Environment(Endpoint) Identifier */
  endpointID?: number;
}

export interface EndpointsEndpointSettingsUpdatePayload {
  /** Whether automatic update time restrictions are enabled */
  changeWindow?: PortainereeEndpointChangeWindow;
  /** Hide manual deployment forms for an environment */
  deploymentOptions?: PortainereeDeploymentOptions;
  /** @example false */
  enableGPUManagement?: boolean;
  /** @example true */
  enableImageNotification?: boolean;
  gpus?: PortainereePair[];
  /** Security settings updates */
  securitySettings?: {
    /**
     * Whether non-administrator should be able to use bind mounts when creating containers
     * @example false
     */
    allowBindMountsForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use container capabilities
     * @example true
     */
    allowContainerCapabilitiesForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use device mapping
     * @example true
     */
    allowDeviceMappingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use the host pid
     * @example true
     */
    allowHostNamespaceForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use privileged mode when creating containers
     * @example false
     */
    allowPrivilegedModeForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to manage stacks
     * @example true
     */
    allowStackManagementForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to use sysctl settings
     * @example true
     */
    allowSysctlSettingForRegularUsers?: boolean;
    /**
     * Whether non-administrator should be able to browse volumes
     * @example true
     */
    allowVolumeBrowserForRegularUsers?: boolean;
    /**
     * Whether host management features are enabled
     * @example true
     */
    enableHostManagementFeatures?: boolean;
  };
}

export interface EndpointsEndpointUpdatePayload {
  /** Hide manual deployment forms for an environment */
  DeploymentOptions?: PortainereeDeploymentOptions;
  /**
   * Azure application ID
   * @example "eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4"
   */
  azureApplicationID?: string;
  /**
   * Azure authentication key
   * @example "cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk="
   */
  azureAuthenticationKey?: string;
  /**
   * Azure tenant ID
   * @example "34ddc78d-4fel-2358-8cc1-df84c8o839f5"
   */
  azureTenantID?: string;
  /** Whether automatic update time restrictions are enabled */
  changeWindow?: PortainereeEndpointChangeWindow;
  edge?: {
    /**
     * The command list interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    CommandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    PingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    SnapshotInterval?: number;
  };
  /**
   * The check in interval for edge agent (in seconds)
   * @example 5
   */
  edgeCheckinInterval?: number;
  /** GPUs information */
  gpus?: PortainereePair[];
  /**
   * Group identifier
   * @example 1
   */
  groupID?: number;
  /** Associated Kubernetes data */
  kubernetes?: PortainereeKubernetesData;
  /**
   * Name that will be used to identify this environment(endpoint)
   * @example "my-environment"
   */
  name?: string;
  /**
   * URL or IP address where exposed containers will be reachable.\
   * Defaults to URL if not specified
   * @example "docker.mydomain.tld:2375"
   */
  publicURL?: string;
  /**
   * The status of the environment(endpoint) (1 - up, 2 - down)
   * @example 1
   */
  status?: number;
  /**
   * List of tag identifiers to which this environment(endpoint) is associated
   * @example [1,2]
   */
  tagIDs?: number[];
  teamAccessPolicies?: PortainereeTeamAccessPolicies;
  /**
   * Require TLS to connect against this environment(endpoint)
   * @example true
   */
  tls?: boolean;
  /**
   * Skip client verification when using TLS
   * @example false
   */
  tlsskipClientVerify?: boolean;
  /**
   * Skip server verification when using TLS
   * @example false
   */
  tlsskipVerify?: boolean;
  /**
   * URL or IP address of a Docker host
   * @example "docker.mydomain.tld:2375"
   */
  url?: string;
  userAccessPolicies?: PortainereeUserAccessPolicies;
}

export interface EndpointsForceUpdateServicePayload {
  /** PullImage if true will pull the image */
  pullImage?: boolean;
  /** ServiceId to update */
  serviceID?: string;
}

export interface EndpointsRegistryAccessPayload {
  namespaces?: string[];
  teamAccessPolicies?: PortainereeTeamAccessPolicies;
  userAccessPolicies?: PortainereeUserAccessPolicies;
}

export interface EndpointsResourcePoolUpdatePayload {
  teamsToAdd?: number[];
  teamsToRemove?: number[];
  usersToAdd?: number[];
  usersToRemove?: number[];
}

export interface FdoDeviceConfigurePayload {
  edgeID?: string;
  edgeKey?: string;
  name?: string;
  profile?: number;
}

export interface FdoFdoConfigurePayload {
  enabled?: boolean;
  ownerPassword?: string;
  ownerURL?: string;
  ownerUsername?: string;
}

export interface GithubComPortainerPortainerEeApiDemoEnvironmentDetails {
  enabled?: boolean;
  environments?: number[];
  users?: number[];
}

export interface GithubComPortainerPortainerEeApiHttpHandlerSystemBuildInfo {
  buildNumber?: string;
  goVersion?: string;
  imageTag?: string;
  nodejsVersion?: string;
  webpackVersion?: string;
  yarnVersion?: string;
}

export interface GithubComPortainerPortainerEeApiHttpHandlerSystemNodesCountResponse {
  nodes?: number;
}

export interface GithubComPortainerPortainerEeApiHttpHandlerSystemStatus {
  /**
   * Portainer API version
   * @example "2.0.0"
   */
  Version?: string;
  demoEnvironment?: GithubComPortainerPortainerEeApiDemoEnvironmentDetails;
  /**
   * Server Instance ID
   * @example "299ab403-70a8-4c05-92f7-bf7a994d50df"
   */
  instanceID?: string;
}

export interface GithubComPortainerPortainerEeApiHttpHandlerSystemVersionResponse {
  /**
   * The latest version available
   * @example "2.0.0"
   */
  LatestVersion?: string;
  /**
   * Whether portainer has an update available
   * @example false
   */
  UpdateAvailable?: boolean;
  build?: GithubComPortainerPortainerEeApiHttpHandlerSystemBuildInfo;
  databaseVersion?: string;
  serverVersion?: string;
}

export interface GithubComPortainerPortainerApiDemoEnvironmentDetails {
  enabled?: boolean;
  environments?: number[];
  users?: number[];
}

export interface GithubComPortainerPortainerApiHttpHandlerSystemBuildInfo {
  buildNumber?: string;
  goVersion?: string;
  imageTag?: string;
  nodejsVersion?: string;
  webpackVersion?: string;
  yarnVersion?: string;
}

export interface GithubComPortainerPortainerApiHttpHandlerSystemNodesCountResponse {
  nodes?: number;
}

export interface GithubComPortainerPortainerApiHttpHandlerSystemStatus {
  /**
   * Portainer API version
   * @example "2.0.0"
   */
  Version?: string;
  demoEnvironment?: GithubComPortainerPortainerApiDemoEnvironmentDetails;
  /**
   * Server Instance ID
   * @example "299ab403-70a8-4c05-92f7-bf7a994d50df"
   */
  instanceID?: string;
}

export interface GithubComPortainerPortainerApiHttpHandlerSystemVersionResponse {
  /**
   * The latest version available
   * @example "2.0.0"
   */
  LatestVersion?: string;
  /**
   * Whether portainer has an update available
   * @example false
   */
  UpdateAvailable?: boolean;
  build?: GithubComPortainerPortainerApiHttpHandlerSystemBuildInfo;
  databaseVersion?: string;
  serverVersion?: string;
}

export interface GitopsRepositoryFileSearchPayload {
  gitCredentialID?: number;
  /**
   * Allow to provide specific file extension as the search result. If empty, the file extensions yml,yaml,hcl,json will be set by default
   * @example "json,yml"
   */
  include?: string;
  /**
   * Partial or completed file name. If empty, all filenames with included extensions will be returned
   * @example "docker-compose"
   */
  keyword?: string;
  password?: string;
  /**
   * Specific Git repository reference. If empty, the reference ref/heads/main will be set by default
   * @example "refs/heads/develop"
   */
  reference?: string;
  repository: string;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
  username?: string;
}

export interface GitopsRepositoryReferenceListPayload {
  gitCredentialID?: number;
  password?: string;
  repository: string;
  stackID?: number;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
  username?: string;
}

export interface GittypesGitAuthentication {
  /**
   * Git credentials identifier when the value is not 0
   * When the value is 0, Username and Password are set without using saved credential
   * This is introduced since 2.15.0
   * @example 0
   */
  gitCredentialID?: number;
  password?: string;
  username?: string;
}

export interface GittypesRepoConfig {
  /** Git credentials */
  authentication?: GittypesGitAuthentication;
  /**
   * Path to where the config file is in this url/refName
   * @example "docker-compose.yml"
   */
  configFilePath?: string;
  /**
   * Repository hash
   * @example "bc4c183d756879ea4d173315338110b31004b8e0"
   */
  configHash?: string;
  /**
   * The reference name
   * @example "refs/heads/branch_name"
   */
  referenceName?: string;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
  /**
   * The repo url
   * @example "https://github.com/portainer/portainer.git"
   */
  url?: string;
}

export interface HelmAddHelmRepoUrlPayload {
  url?: string;
}

export interface HelmHelmUserRepositoryResponse {
  GlobalRepository?: string;
  UserRepositories?: PortainereeHelmUserRepository[];
}

export interface HelmInstallChartPayload {
  chart?: string;
  name?: string;
  namespace?: string;
  repo?: string;
  values?: string;
}

export interface KubernetesNamespacesToggleSystemPayload {
  /**
   * Toggle the system state of this namespace to true or false
   * @example true
   */
  system?: boolean;
}

export interface LdapAdminGroupsPayload {
  ldapsettings?: PortainereeLDAPSettings;
}

export interface LdapCheckPayload {
  ldapsettings?: PortainereeLDAPSettings;
}

export interface LdapGroupsPayload {
  ldapsettings?: PortainereeLDAPSettings;
}

export interface LdapTestLoginPayload {
  ldapsettings?: PortainereeLDAPSettings;
  password?: string;
  username?: string;
}

export interface LdapTestLoginResponse {
  valid?: boolean;
}

export interface LdapUsersPayload {
  ldapsettings?: PortainereeLDAPSettings;
}

export interface LiblicensePortainerLicense {
  company?: string;
  created?: number;
  email?: string;
  expiresAfter?: number;
  expiresAt?: number;
  firstCheckin?: number;
  id?: string;
  lastCheckin?: number;
  licenseKey?: string;
  nodes?: number;
  /**
   * ProductEdition was created originally with plans on having a
   * seperate portainer product for Enterprise users and Business users
   * with differing features. This didn't wind up coming about, but may
   * still serve useful in the future if we need to issue keys for a
   * different product entirely.
   * Originally, the ProductEdition was used as the prefix for generating
   * license keys, but in practice most people thought it was the
   * "version" due to us having the original extension licenses which can
   * be thought of as the true version 1 licenses.
   */
  productEdition?: number;
  redisRef?: string;
  reference?: string;
  revoked?: boolean;
  revokedAt?: number;
  /**
   * Type is used to distinguish different kinds of licenses, trial
   * licenses, enterprise subscriptions
   */
  type?: number;
  uniqueId?: string;
  /**
   * Version indicates which key should be used to encode/decode the
   * license string.
   */
  version?: number;
}

export interface LicensesLicenseInfo {
  company?: string;
  enforcedAt?: number;
  expiresAt?: number;
  nodes?: number;
  /** unix timestamp when node usage exceeded avaiable license limit */
  overuseStartedTimestamp?: number;
  type?: number;
  valid?: boolean;
}

export interface LicensesAttachPayload {
  key?: string;
}

export interface LicensesAttachResponse {
  conflictingKeys?: string[];
}

export interface LicensesDeletePayload {
  /** List of license keys to remove */
  licenseKeys?: string[];
}

export interface ModelsCloudCredential {
  /** @example 1650000000 */
  created?: number;
  credentials?: ModelsCloudCredentialMap;
  /** @example 1 */
  id?: number;
  /** @example "test-env" */
  name?: string;
  /** @example "aws" */
  provider?: string;
}

export type ModelsCloudCredentialMap = Record<string, string>;

export interface ModelsK8SApplication {
  kind?: string;
  labels?: Record<string, string>;
  name?: string;
  namespace?: string;
  uid?: string;
}

export interface ModelsSSHKeyPair {
  private?: string;
  public?: string;
}

export interface MotdMotdResponse {
  ContentLayout?: Record<string, string>;
  Hash?: number[];
  Message?: string;
  Style?: string;
  Title?: string;
}

export interface NetworkEndpointIPAMConfig {
  ipv4Address?: string;
  ipv6Address?: string;
  linkLocalIPs?: string[];
}

export interface NetworkEndpointSettings {
  aliases?: string[];
  driverOpts?: Record<string, string>;
  endpointID?: string;
  gateway?: string;
  globalIPv6Address?: string;
  globalIPv6PrefixLen?: number;
  ipaddress?: string;
  /** Configurations */
  ipamconfig?: NetworkEndpointIPAMConfig;
  ipprefixLen?: number;
  ipv6Gateway?: string;
  links?: string[];
  macAddress?: string;
  /** Operational data */
  networkID?: string;
}

export interface NomadSlimNomadTaskEvent {
  date?: number;
  message?: string;
  type?: string;
}

export interface OpenamtDeviceActionPayload {
  action?: string;
}

export interface OpenamtDeviceFeaturesPayload {
  features?: PortainerOpenAMTDeviceEnabledFeatures;
}

export interface OpenamtOpenAMTConfigurePayload {
  certFileContent?: string;
  certFileName?: string;
  certFilePassword?: string;
  domainName?: string;
  enabled?: boolean;
  mpspassword?: string;
  mpsserver?: string;
  mpsuser?: string;
}

export interface PodsecurityPodSecurityAllowFlexVolumes {
  allowedVolumes?: string[];
  enabled?: boolean;
}

export interface PodsecurityPodSecurityAllowPrivilegeEscalation {
  enabled?: boolean;
}

export interface PodsecurityPodSecurityAllowProcMount {
  enabled?: boolean;
  procMountType?: string;
}

export interface PodsecurityPodSecurityAllowedCapabilities {
  level?: string;
  role?: string;
  type?: string;
  user?: string;
}

export interface PodsecurityPodSecurityAllowedPaths {
  pathPrefix?: string;
  readonly?: boolean;
}

export interface PodsecurityPodSecurityAppArmour {
  AppArmorType?: string[];
  enabled?: boolean;
}

export interface PodsecurityPodSecurityCapabilities {
  allowedCapabilities?: string[];
  enabled?: boolean;
  requiredDropCapabilities?: string[];
}

export interface PodsecurityPodSecurityForbiddenSysctlsList {
  enabled?: boolean;
  requiredDropCapabilities?: string[];
}

export interface PodsecurityPodSecurityFsGroups {
  idrange?: PodsecurityPodSecurityIdrange[];
  type?: string;
}

export interface PodsecurityPodSecurityHostFilesystem {
  allowedPaths?: PodsecurityPodSecurityAllowedPaths[];
  enabled?: boolean;
}

export interface PodsecurityPodSecurityHostNamespaces {
  enabled?: boolean;
}

export interface PodsecurityPodSecurityHostNetworkingPorts {
  enabled?: boolean;
  hostNetwork?: boolean;
  max?: number;
  min?: number;
}

export interface PodsecurityPodSecurityIdrange {
  max?: number;
  min?: number;
}

export interface PodsecurityPodSecurityPrivilegedContainers {
  enabled?: boolean;
}

export interface PodsecurityPodSecurityReadOnlyRootFileSystem {
  enabled?: boolean;
}

export interface PodsecurityPodSecurityRule {
  allowFlexVolumes?: PodsecurityPodSecurityAllowFlexVolumes;
  allowPrivilegeEscalation?: PodsecurityPodSecurityAllowPrivilegeEscalation;
  allowProcMount?: PodsecurityPodSecurityAllowProcMount;
  appArmor?: PodsecurityPodSecurityAppArmour;
  capabilities?: PodsecurityPodSecurityCapabilities;
  enabled?: boolean;
  endPointID?: number;
  forbiddenSysctlsList?: PodsecurityPodSecurityForbiddenSysctlsList;
  hostFilesystem?: PodsecurityPodSecurityHostFilesystem;
  hostNamespaces?: PodsecurityPodSecurityHostNamespaces;
  hostPorts?: PodsecurityPodSecurityHostNetworkingPorts;
  id?: number;
  privilegedContainers?: PodsecurityPodSecurityPrivilegedContainers;
  readOnlyRootFileSystem?: PodsecurityPodSecurityReadOnlyRootFileSystem;
  secComp?: PodsecurityPodSecuritySecComp;
  selinux?: PodsecurityPodSecuritySelinux;
  users?: PodsecurityPodSecurityUsers;
  volumeTypes?: PodsecurityPodSecurityVolumeTypes;
}

export interface PodsecurityPodSecurityRunAsGroup {
  idrange?: PodsecurityPodSecurityIdrange[];
  type?: string;
}

export interface PodsecurityPodSecurityRunAsUser {
  idrange?: PodsecurityPodSecurityIdrange[];
  type?: string;
}

export interface PodsecurityPodSecuritySecComp {
  enabled?: boolean;
  secCompType?: string[];
}

export interface PodsecurityPodSecuritySelinux {
  allowedCapabilities?: PodsecurityPodSecurityAllowedCapabilities[];
  enabled?: boolean;
}

export interface PodsecurityPodSecuritySupplementalGroups {
  idrange?: PodsecurityPodSecurityIdrange[];
  type?: string;
}

export interface PodsecurityPodSecurityUsers {
  enabled?: boolean;
  fsGroups?: PodsecurityPodSecurityFsGroups;
  runAsGroup?: PodsecurityPodSecurityRunAsGroup;
  runAsUser?: PodsecurityPodSecurityRunAsUser;
  supplementalGroups?: PodsecurityPodSecuritySupplementalGroups;
}

export interface PodsecurityPodSecurityVolumeTypes {
  allowedTypes?: string[];
  enabled?: boolean;
}

export interface PortainerDockerContainerSnapshot {
  /** EE-5240 */
  Env?: string[];
  Id?: string;
  command?: string;
  created?: number;
  hostConfig?: {
    networkMode?: string;
  };
  image?: string;
  imageID?: string;
  labels?: Record<string, string>;
  mounts?: TypesMountPoint[];
  names?: string[];
  networkSettings?: TypesSummaryNetworkSettings;
  ports?: TypesPort[];
  sizeRootFs?: number;
  sizeRw?: number;
  state?: string;
  status?: string;
}

export interface PortainerDockerSnapshot {
  DockerSnapshotRaw?: PortainerDockerSnapshotRaw;
  DockerVersion?: string;
  GpuUseAll?: boolean;
  GpuUseList?: string[];
  HealthyContainerCount?: number;
  ImageCount?: number;
  NodeCount?: number;
  RunningContainerCount?: number;
  ServiceCount?: number;
  StackCount?: number;
  StoppedContainerCount?: number;
  Swarm?: boolean;
  Time?: number;
  TotalCPU?: number;
  TotalMemory?: number;
  UnhealthyContainerCount?: number;
  VolumeCount?: number;
}

export type PortainerDockerSnapshotRaw = object;

export interface PortainerEdgeStackStatus {
  Details?: PortainerEdgeStackStatusDetails;
  EndpointID?: number;
  Error?: string;
  /** Deprecated */
  Type?: number;
}

export interface PortainerEdgeStackStatusDetails {
  acknowledged?: boolean;
  error?: boolean;
  imagesPulled?: boolean;
  ok?: boolean;
  pending?: boolean;
  remoteUpdateSuccess?: boolean;
  remove?: boolean;
}

export interface PortainerOpenAMTConfiguration {
  certFileContent?: string;
  certFileName?: string;
  certFilePassword?: string;
  domainName?: string;
  enabled?: boolean;
  mpsPassword?: string;
  mpsServer?: string;
  /** retrieved from API */
  mpsToken?: string;
  mpsUser?: string;
}

export interface PortainerOpenAMTDeviceEnabledFeatures {
  IDER?: boolean;
  KVM?: boolean;
  SOL?: boolean;
  redirection?: boolean;
  userConsent?: string;
}

export interface PortainereeAPIKey {
  /** Unix timestamp (UTC) when the API key was created */
  dateCreated?: number;
  /** @example "portainer-api-key" */
  description?: string;
  /** Digest represents SHA256 hash of the raw API key */
  digest?: number[];
  /** @example 1 */
  id?: number;
  /** Unix timestamp (UTC) when the API key was last used */
  lastUsed?: number;
  /** API key identifier (7 char prefix) */
  prefix?: string;
  /**
   * User Identifier
   * @example 1
   */
  userId?: number;
}

export interface PortainereeAccessPolicy {
  /**
   * Role identifier. Reference the role that will be associated to this access policy
   * @example 1
   */
  RoleId?: number;
}

export interface PortainereeAuthActivityLog {
  /** Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth */
  context?: number;
  id?: number;
  origin?: string;
  timestamp?: number;
  type?: number;
  username?: string;
}

export type PortainereeAuthorizations = Record<string, boolean>;

export interface PortainereeAutoUpdateSettings {
  /**
   * Pull latest image
   * @example false
   */
  forcePullImage?: boolean;
  /**
   * Force update ignores repo changes
   * @example false
   */
  forceUpdate?: boolean;
  /**
   * Auto update interval
   * @example "1m30s"
   */
  interval?: string;
  /**
   * Autoupdate job id
   * @example "15"
   */
  jobID?: string;
  /**
   * A UUID generated from client
   * @example "05de31a2-79fa-4644-9c12-faa67e5c49f0"
   */
  webhook?: string;
}

export interface PortainereeAzureCredentials {
  /**
   * Azure application ID
   * @example "eag7cdo9-o09l-9i83-9dO9-f0b23oe78db4"
   */
  ApplicationID?: string;
  /**
   * Azure authentication key
   * @example "cOrXoK/1D35w8YQ8nH1/8ZGwzz45JIYD5jxHKXEQknk="
   */
  AuthenticationKey?: string;
  /**
   * Azure tenant ID
   * @example "34ddc78d-4fel-2358-8cc1-df84c8o839f5"
   */
  TenantID?: string;
}

export interface PortainereeCloudApiKeys {
  /** @example "DgJ33kwIhnHumQFyc8ihGwWJql9cC8UJDiBhN8YImKqiX" */
  CivoApiKey?: string;
  /** @example "dop_v1_n9rq7dkcbg3zb3bewtk9nnvmfkyfnr94d42n28lym22vhqu23rtkllsldygqm22v" */
  DigitalOceanToken?: string;
  /** @example "an entire base64ed key file" */
  GKEApiKey?: string;
  /** @example "92gsh9r9u5helgs4eibcuvlo403vm45hrmc6mzbslotnrqmkwc1ovqgmolcyq0wc" */
  LinodeToken?: string;
}

export interface PortainereeCloudProvider {
  /** MicroK8S specific fields */
  Addons?: string;
  /** Amazon specific fields */
  AmiType?: string;
  CPU?: number;
  /** CredentialID holds an ID of the credential used to create the cluster */
  CredentialID?: number;
  HDD?: number;
  InstanceType?: string;
  Name?: string;
  /**
   * Pointer will hide this field for providers other than civo which do
   * not use this field.
   */
  NetworkID?: string;
  NodeCount?: number;
  NodeIPs?: string;
  NodeVolumeSize?: number;
  RAM?: number;
  Region?: string;
  Size?: string;
  URL?: string;
  dnsprefix?: string;
  kubernetesVersion?: string;
  poolName?: string;
  /** Azure specific fields */
  resourceGroup?: string;
  tier?: string;
}

export interface PortainereeCustomTemplate {
  /**
   * User identifier who created this template
   * @example 3
   */
  CreatedByUserId?: number;
  /**
   * Description of the template
   * @example "High performance web server"
   */
  Description?: string;
  /**
   * Path to the Stack file
   * @example "docker-compose.yml"
   */
  EntryPoint?: string;
  /**
   * CustomTemplate Identifier
   * @example 1
   */
  Id?: number;
  /**
   * URL of the template's logo
   * @example "https://cloudinovasi.id/assets/img/logos/nginx.png"
   */
  Logo?: string;
  /**
   * A note that will be displayed in the UI. Supports HTML content
   * @example "This is my <b>custom</b> template"
   */
  Note?: string;
  /**
   * Platform associated to the template.
   * Valid values are: 1 - 'linux', 2 - 'windows'
   * @example 1
   */
  Platform?: 1 | 2;
  /**
   * Path on disk to the repository hosting the Stack file
   * @example "/data/custom_template/3"
   */
  ProjectPath?: string;
  ResourceControl?: PortainereeResourceControl;
  /**
   * Title of the template
   * @example "Nginx"
   */
  Title?: string;
  /**
   * Type of created stack (1 - swarm, 2 - compose)
   * @example 1
   */
  Type?: number;
  variables?: PortainereeCustomTemplateVariableDefinition[];
}

export interface PortainereeCustomTemplateVariableDefinition {
  /** @example "default value" */
  defaultValue?: string;
  /** @example "Description" */
  description?: string;
  /** @example "My Variable" */
  label?: string;
  /** @example "MY_VAR" */
  name?: string;
}

export interface PortainereeDeploymentOptions {
  /**
   * Hide manual deploy forms in portainer
   * @example true
   */
  hideAddWithForm?: boolean;
  /**
   * Hide the file upload option in the remaining visible forms
   * @example false
   */
  hideFileUpload?: boolean;
  /**
   * Hide the webeditor in the remaining visible forms
   * @example false
   */
  hideWebEditor?: boolean;
  overrideGlobalOptions?: boolean;
}

export interface PortainereeEcrData {
  /** @example "ap-southeast-2" */
  Region?: string;
}

export interface PortainereeEdge {
  /**
   * The command list interval for edge agent - used in edge async mode (in seconds)
   * @example 5
   */
  CommandInterval?: number;
  /**
   * The ping interval for edge agent - used in edge async mode (in seconds)
   * @example 5
   */
  PingInterval?: number;
  /**
   * The snapshot interval for edge agent - used in edge async mode (in seconds)
   * @example 5
   */
  SnapshotInterval?: number;
  /**
   * The address where the tunneling server can be reached by Edge agents
   * @example "portainer.domain.tld"
   */
  TunnelServerAddress?: string;
  /** Deprecated 2.18 */
  asyncMode?: boolean;
  mtls?: PortainereeMTLSSettings;
}

export interface PortainereeEdgeAsyncCommand {
  endpointID?: number;
  executed?: boolean;
  id?: number;
  op?: string;
  path?: string;
  scheduledTime?: string;
  timestamp?: string;
  type?: string;
  value?: any;
}

export interface PortainereeEdgeGroup {
  Dynamic?: boolean;
  Endpoints?: number[];
  /**
   * EdgeGroup Identifier
   * @example 1
   */
  Id?: number;
  Name?: string;
  PartialMatch?: boolean;
  TagIds?: number[];
}

export interface PortainereeEdgeJob {
  Created?: number;
  CronExpression?: string;
  EdgeGroups?: number[];
  Endpoints?: Record<string, PortainereeEdgeJobEndpointMeta>;
  /**
   * EdgeJob Identifier
   * @example 1
   */
  Id?: number;
  Name?: string;
  Recurring?: boolean;
  ScriptPath?: string;
  Version?: number;
  /** Field used for log collection of Endpoints belonging to EdgeGroups */
  groupLogsCollection?: Record<string, PortainereeEdgeJobEndpointMeta>;
}

export interface PortainereeEdgeJobEndpointMeta {
  collectLogs?: boolean;
  logsStatus?: number;
}

export interface PortainereeEdgeRegistryCredential {
  secret?: string;
  serverURL?: string;
  username?: string;
}

export interface PortainereeEdgeStack {
  CreationDate?: number;
  /**
   * Deployment type to deploy this stack
   * Valid values are: 0 - 'compose', 1 - 'kubernetes', 2 - 'nomad'
   * for compose stacks will use kompose to convert to kubernetes manifest for kubernetes environments(endpoints)
   * kubernetes deploy type is enabled only for kubernetes environments(endpoints)
   * nomad deploy type is enabled only for nomad environments(endpoints)
   */
  DeploymentType?: number;
  EdgeGroups?: number[];
  EntryPoint?: string;
  /**
   * EdgeStack Identifier
   * @example 1
   */
  Id?: number;
  ManifestPath?: string;
  Name?: string;
  NumDeployments?: number;
  /** Pre Pull Image */
  PrePullImage?: boolean;
  ProjectPath?: string;
  /** Deprecated */
  Prune?: boolean;
  /** Re-Pull Image */
  RePullImage?: boolean;
  Registries?: number[];
  Status?: Record<string, PortainerEdgeStackStatus>;
  Version?: number;
  /** EdgeUpdateID represents the parent update ID, will be zero if this stack is not part of an update */
  edgeUpdateID?: number;
  /**
   * Retry deploy
   * @example false
   */
  retryDeploy?: boolean;
  /**
   * Schedule represents the schedule of the Edge stack (optional, format - 'YYYY-MM-DD HH:mm:ss')
   * @example "2020-11-13 14:53:00"
   */
  scheduledTime?: string;
  /** Uses the manifest's namespaces instead of the default one */
  useManifestNamespaces?: boolean;
}

export interface PortainereeEndpoint {
  /**
   * The identifier of the AMT Device associated with this environment(endpoint)
   * @example "4c4c4544-004b-3910-8037-b6c04f504633"
   */
  AMTDeviceGUID?: string;
  AuthorizedTeams?: number[];
  /** Deprecated in DBVersion == 18 */
  AuthorizedUsers?: number[];
  AzureCredentials?: PortainereeAzureCredentials;
  /** Automatic update change window restriction for stacks and apps */
  ChangeWindow?: PortainereeEndpointChangeWindow;
  /**
   * A Kubernetes as a service cloud provider. Only included if this
   * endpoint was created using KaaS provisioning.
   */
  CloudProvider?: PortainereeCloudProvider;
  /**
   * Maximum version of docker-compose
   * @example "3.8"
   */
  ComposeSyntaxMaxVersion?: string;
  /** Hide manual deployment forms for an environment */
  DeploymentOptions?: PortainereeDeploymentOptions;
  /**
   * The check in interval for edge agent (in seconds)
   * @example 5
   */
  EdgeCheckinInterval?: number;
  /** The identifier of the edge agent associated with this environment(endpoint) */
  EdgeID?: string;
  /** The key which is used to map the agent to Portainer */
  EdgeKey?: string;
  EnableGPUManagement?: boolean;
  EnableImageNotification?: boolean;
  Gpus?: PortainereePair[];
  /**
   * Environment(Endpoint) group identifier
   * @example 1
   */
  GroupId?: number;
  /**
   * Heartbeat indicates the heartbeat status of an edge environment
   * @example true
   */
  Heartbeat?: boolean;
  /**
   * Environment(Endpoint) Identifier
   * @example 1
   */
  Id?: number;
  /** Associated Kubernetes data */
  Kubernetes?: PortainereeKubernetesData;
  /**
   * Environment(Endpoint) name
   * @example "my-environment"
   */
  Name?: string;
  /** Associated Nomad data */
  Nomad?: PortainereeNomadData;
  /** Whether we need to run any "post init migrations". */
  PostInitMigrations?: PortainereeEndpointPostInitMigrations;
  /**
   * URL or IP address where exposed containers will be reachable
   * @example "docker.mydomain.tld:2375"
   */
  PublicURL?: string;
  /** List of snapshots */
  Snapshots?: PortainerDockerSnapshot[];
  /**
   * The status of the environment(endpoint) (1 - up, 2 - down, 3 -
   * provisioning, 4 - error)
   * @example 1
   */
  Status?: number;
  /**
   * A message that describes the status. Should be included for Status 3
   * or 4.
   */
  StatusMessage?: PortainereeEndpointStatusMessage;
  /**
   * Deprecated fields
   * Deprecated in DBVersion == 4
   */
  TLS?: boolean;
  TLSCACert?: string;
  TLSCert?: string;
  TLSConfig?: PortainereeTLSConfiguration;
  TLSKey?: string;
  /** List of tag identifiers to which this environment(endpoint) is associated */
  TagIds?: number[];
  /** Deprecated in DBVersion == 22 */
  Tags?: string[];
  /** List of team identifiers authorized to connect to this environment(endpoint) */
  TeamAccessPolicies?: PortainereeTeamAccessPolicies;
  /**
   * Environment(Endpoint) environment(endpoint) type. 1 for a Docker environment(endpoint), 2 for an agent on Docker environment(endpoint) or 3 for an Azure environment(endpoint).
   * @example 1
   */
  Type?: number;
  /**
   * URL or IP address of the Docker host associated to this environment(endpoint)
   * @example "docker.mydomain.tld:2375"
   */
  URL?: string;
  /** List of user identifiers authorized to connect to this environment(endpoint) */
  UserAccessPolicies?: PortainereeUserAccessPolicies;
  agent?: {
    /** @example "1.0.0" */
    version?: string;
  };
  edge?: PortainereeEnvironmentEdgeSettings;
  /** IsEdgeDevice marks if the environment was created as an EdgeDevice */
  isEdgeDevice?: boolean;
  /** LastCheckInDate mark last check-in date on checkin */
  lastCheckInDate?: number;
  /** LocalTimeZone is the local time zone of the endpoint */
  localTimeZone?: string;
  /** QueryDate of each query with the endpoints list */
  queryDate?: number;
  /** Environment(Endpoint) specific security settings */
  securitySettings?: PortainereeEndpointSecuritySettings;
  /** Whether the device has been trusted or not by the user */
  userTrusted?: boolean;
}

export type PortainereeEndpointAuthorizations = Record<string, PortainereeAuthorizations>;

export interface PortainereeEndpointChangeWindow {
  /** @example true */
  Enabled?: boolean;
  /** @example "02:00" */
  EndTime?: string;
  /** @example "22:00" */
  StartTime?: string;
}

export interface PortainereeEndpointGroup {
  AuthorizedTeams?: number[];
  /** Deprecated in DBVersion == 18 */
  AuthorizedUsers?: number[];
  /**
   * Description associated to the environment(endpoint) group
   * @example "Environment(Endpoint) group description"
   */
  Description?: string;
  /**
   * Environment(Endpoint) group Identifier
   * @example 1
   */
  Id?: number;
  /** Deprecated fields */
  Labels?: PortainereePair[];
  /**
   * Environment(Endpoint) group name
   * @example "my-environment-group"
   */
  Name?: string;
  /** List of tags associated to this environment(endpoint) group */
  TagIds?: number[];
  /** Deprecated in DBVersion == 22 */
  Tags?: string[];
  TeamAccessPolicies?: PortainereeTeamAccessPolicies;
  UserAccessPolicies?: PortainereeUserAccessPolicies;
}

export interface PortainereeEndpointPostInitMigrations {
  MigrateGPUs?: boolean;
  MigrateGateKeeper?: boolean;
  MigrateIngresses?: boolean;
}

export interface PortainereeEndpointSecuritySettings {
  /**
   * Whether non-administrator should be able to use bind mounts when creating containers
   * @example false
   */
  allowBindMountsForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to use container capabilities
   * @example true
   */
  allowContainerCapabilitiesForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to use device mapping
   * @example true
   */
  allowDeviceMappingForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to use the host pid
   * @example true
   */
  allowHostNamespaceForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to use privileged mode when creating containers
   * @example false
   */
  allowPrivilegedModeForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to manage stacks
   * @example true
   */
  allowStackManagementForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to use sysctl settings
   * @example true
   */
  allowSysctlSettingForRegularUsers?: boolean;
  /**
   * Whether non-administrator should be able to browse volumes
   * @example true
   */
  allowVolumeBrowserForRegularUsers?: boolean;
  /**
   * Whether host management features are enabled
   * @example true
   */
  enableHostManagementFeatures?: boolean;
}

export interface PortainereeEndpointStatusMessage {
  Detail?: string;
  Summary?: string;
}

export interface PortainereeEnvironmentEdgeSettings {
  /**
   * The command list interval for edge agent - used in edge async mode [seconds]
   * @example 60
   */
  CommandInterval?: number;
  /**
   * The ping interval for edge agent - used in edge async mode [seconds]
   * @example 60
   */
  PingInterval?: number;
  /**
   * The snapshot interval for edge agent - used in edge async mode [seconds]
   * @example 60
   */
  SnapshotInterval?: number;
  /** Whether the device has been started in edge async mode */
  asyncMode?: boolean;
}

export interface PortainereeExperimentalFeatures {
  OpenAIIntegration?: boolean;
}

export interface PortainereeFDOConfiguration {
  enabled?: boolean;
  ownerPassword?: string;
  ownerURL?: string;
  ownerUsername?: string;
}

export interface PortainereeGitCredential {
  /** @example 1587399600 */
  creationDate?: number;
  /**
   * GitCredentialID used to identify the binded git credential
   * @example 1
   */
  id?: number;
  name?: string;
  password?: string;
  /**
   * User Identifier
   * @example 1
   */
  userId?: number;
  username?: string;
}

export interface PortainereeGithubRegistryData {
  OrganisationName?: string;
  UseOrganisation?: boolean;
}

export interface PortainereeGitlabRegistryData {
  InstanceURL?: string;
  ProjectId?: number;
  ProjectPath?: string;
}

export interface PortainereeGlobalDeploymentOptions {
  /**
   * Hide manual deploy forms in portainer
   * @example false
   */
  hideAddWithForm?: boolean;
  /**
   * Hide the file upload option in the remaining visible forms
   * @example false
   */
  hideFileUpload?: boolean;
  /**
   * Hide the webeditor in the remaining visible forms
   * @example false
   */
  hideWebEditor?: boolean;
  /**
   * Configure this per environment or globally
   * @example false
   */
  perEnvOverride?: boolean;
}

export interface PortainereeHelmUserRepository {
  /**
   * Membership Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Helm repository URL
   * @example "https://charts.bitnami.com/bitnami"
   */
  URL?: string;
  /**
   * User identifier
   * @example 1
   */
  UserId?: number;
}

export interface PortainereeInternalAuthSettings {
  requiredPasswordLength?: number;
}

export interface PortainereeK8SNodeLimits {
  CPU?: number;
  Memory?: number;
}

export type PortainereeK8SNodesLimits = Record<string, PortainereeK8SNodeLimits>;

export interface PortainereeKubernetesConfiguration {
  AllowNoneIngressClass?: boolean;
  EnableResourceOverCommit?: boolean;
  IngressAvailabilityPerNamespace?: boolean;
  IngressClasses?: PortainereeKubernetesIngressClassConfig[];
  ResourceOverCommitPercentage?: number;
  RestrictDefaultNamespace?: boolean;
  RestrictStandardUserIngressW?: boolean;
  StorageClasses?: PortainereeKubernetesStorageClassConfig[];
  UseLoadBalancer?: boolean;
  UseServerMetrics?: boolean;
}

export interface PortainereeKubernetesData {
  Configuration?: PortainereeKubernetesConfiguration;
  Flags?: PortainereeKubernetesFlags;
  Snapshots?: PortainereeKubernetesSnapshot[];
}

export interface PortainereeKubernetesFlags {
  IsServerIngressClassDetected?: boolean;
  IsServerMetricsDetected?: boolean;
  IsServerStorageDetected?: boolean;
}

export interface PortainereeKubernetesIngressClassConfig {
  Blocked?: boolean;
  BlockedNamespaces?: string[];
  Name?: string;
  Type?: string;
}

export interface PortainereeKubernetesSnapshot {
  KubernetesVersion?: string;
  NodeCount?: number;
  Time?: number;
  TotalCPU?: number;
  TotalMemory?: number;
}

export interface PortainereeKubernetesStorageClassConfig {
  AccessModes?: string[];
  AllowVolumeExpansion?: boolean;
  Name?: string;
  Provisioner?: string;
}

export interface PortainereeLDAPGroupSearchSettings {
  /**
   * LDAP attribute which denotes the group membership
   * @example "member"
   */
  GroupAttribute?: string;
  /**
   * The distinguished name of the element from which the LDAP server will search for groups
   * @example "dc=ldap,dc=domain,dc=tld"
   */
  GroupBaseDN?: string;
  /**
   * The LDAP search filter used to select group elements, optional
   * @example "(objectClass=account"
   */
  GroupFilter?: string;
}

export interface PortainereeLDAPSearchSettings {
  /**
   * The distinguished name of the element from which the LDAP server will search for users
   * @example "dc=ldap,dc=domain,dc=tld"
   */
  BaseDN?: string;
  /**
   * Optional LDAP search filter used to select user elements
   * @example "(objectClass=account)"
   */
  Filter?: string;
  /**
   * LDAP attribute which denotes the username
   * @example "uid"
   */
  UserNameAttribute?: string;
}

export interface PortainereeLDAPSettings {
  /**
   * Whether auto admin population is switched on or not
   * @example true
   */
  AdminAutoPopulate?: boolean;
  AdminGroupSearchSettings?: PortainereeLDAPGroupSearchSettings[];
  /**
   * Saved admin group list, the user will be populated as an admin role if any user group matches the record in the list
   * @example ["['manager'","'operator']"]
   */
  AdminGroups?: string[];
  /**
   * Enable this option if the server is configured for Anonymous access. When enabled, ReaderDN and Password will not be used
   * @example true
   */
  AnonymousMode?: boolean;
  /**
   * Automatically provision users and assign them to matching LDAP group names
   * @example true
   */
  AutoCreateUsers?: boolean;
  GroupSearchSettings?: PortainereeLDAPGroupSearchSettings[];
  /**
   * Password of the account that will be used to search users
   * @example "readonly-password"
   */
  Password?: string;
  /**
   * Account that will be used to search for users
   * @example "cn=readonly-account,dc=ldap,dc=domain,dc=tld"
   */
  ReaderDN?: string;
  SearchSettings?: PortainereeLDAPSearchSettings[];
  /** @example 1 */
  ServerType?: number;
  /**
   * Whether LDAP connection should use StartTLS
   * @example true
   */
  StartTLS?: boolean;
  TLSConfig?: PortainereeTLSConfiguration;
  /** Deprecated */
  URL?: string;
  /** URLs or IP addresses of the LDAP server */
  URLs?: string[];
}

export interface PortainereeLDAPUser {
  groups?: string[];
  name?: string;
}

export interface PortainereeMTLSSettings {
  /** CaCertFile is the path to the mTLS CA certificate file */
  CaCertFile?: string;
  /** CertFile is the path to the mTLS certificate file */
  CertFile?: string;
  /** KeyFile is the path to the mTLS key file */
  KeyFile?: string;
  UseSeparateCert?: boolean;
}

export interface PortainereeNomadData {
  Snapshots?: PortainereeNomadSnapshot[];
}

export interface PortainereeNomadSnapshot {
  GroupCount?: number;
  JobCount?: number;
  Jobs?: PortainereeNomadSnapshotJob[];
  NodeCount?: number;
  NomadVersion?: string;
  RunningTaskCount?: number;
  TaskCount?: number;
  Time?: number;
  TotalCPU?: number;
  TotalMemory?: number;
}

export interface PortainereeNomadSnapshotJob {
  ID?: string;
  Namespace?: string;
  Status?: string;
  SubmitTime?: number;
  Tasks?: PortainereeNomadSnapshotTask[];
}

export interface PortainereeNomadSnapshotTask {
  AllocationID?: string;
  JobID?: string;
  Namespace?: string;
  StartedAt?: string;
  State?: string;
  TaskGroup?: string;
  TaskName?: string;
}

export interface PortainereeOAuthClaimMappings {
  ClaimValRegex?: string;
  Team?: number;
}

export interface PortainereeOAuthSettings {
  AccessTokenURI?: string;
  AuthorizationURI?: string;
  ClientID?: string;
  ClientSecret?: string;
  DefaultTeamID?: number;
  HideInternalAuth?: boolean;
  KubeSecretKey?: number[];
  LogoutURI?: string;
  MicrosoftTenantID?: string;
  OAuthAutoCreateUsers?: boolean;
  OAuthAutoMapTeamMemberships?: boolean;
  RedirectURI?: string;
  ResourceURI?: string;
  SSO?: boolean;
  Scopes?: string;
  TeamMemberships?: PortainereeTeamMemberships;
  UserIdentifier?: string;
}

export interface PortainereePair {
  /** @example "name" */
  name?: string;
  /** @example "value" */
  value?: string;
}

export interface PortainereeQuayRegistryData {
  OrganisationName?: string;
  UseOrganisation?: boolean;
}

export interface PortainereeRegistry {
  /** Stores temporary access token */
  AccessToken?: string;
  AccessTokenExpiry?: number;
  /**
   * Is authentication against this registry enabled
   * @example true
   */
  Authentication?: boolean;
  /** Deprecated in DBVersion == 18 */
  AuthorizedTeams?: number[];
  /** Deprecated in DBVersion == 18 */
  AuthorizedUsers?: number[];
  /**
   * Base URL, introduced for ProGet registry
   * @example "registry.mydomain.tld:2375"
   */
  BaseURL?: string;
  Ecr?: PortainereeEcrData;
  Github?: PortainereeGithubRegistryData;
  Gitlab?: PortainereeGitlabRegistryData;
  /**
   * Registry Identifier
   * @example 1
   */
  Id?: number;
  ManagementConfiguration?: PortainereeRegistryManagementConfiguration;
  /**
   * Registry Name
   * @example "my-registry"
   */
  Name?: string;
  /**
   * Password or SecretAccessKey used to authenticate against this registry
   * @example "registry_password"
   */
  Password?: string;
  Quay?: PortainereeQuayRegistryData;
  RegistryAccesses?: PortainereeRegistryAccesses;
  /** Deprecated in DBVersion == 31 */
  TeamAccessPolicies?: PortainereeTeamAccessPolicies;
  /** Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR, 8 - Github) */
  Type?: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
  /**
   * URL or IP address of the Docker registry
   * @example "registry.mydomain.tld:2375/feed-name"
   */
  URL?: string;
  /**
   * Deprecated fields
   * Deprecated in DBVersion == 31
   */
  UserAccessPolicies?: PortainereeUserAccessPolicies;
  /**
   * Username or AccessKeyID used to authenticate against this registry
   * @example "registry user"
   */
  Username?: string;
}

export interface PortainereeRegistryAccessPolicies {
  Namespaces?: string[];
  TeamAccessPolicies?: PortainereeTeamAccessPolicies;
  UserAccessPolicies?: PortainereeUserAccessPolicies;
}

export type PortainereeRegistryAccesses = Record<string, PortainereeRegistryAccessPolicies>;

export interface PortainereeRegistryManagementConfiguration {
  AccessToken?: string;
  AccessTokenExpiry?: number;
  Authentication?: boolean;
  Ecr?: PortainereeEcrData;
  Password?: string;
  TLSConfig?: PortainereeTLSConfiguration;
  /** Registry Type (1 - Quay, 2 - Azure, 3 - Custom, 4 - Gitlab, 5 - ProGet, 6 - DockerHub, 7 - ECR, 8 - Github) */
  Type?: number;
  Username?: string;
}

export interface PortainereeResourceControl {
  AccessLevel?: number;
  /**
   * Permit access to resource only to admins
   * @example true
   */
  AdministratorsOnly?: boolean;
  /**
   * ResourceControl Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Deprecated fields
   * Deprecated in DBVersion == 2
   */
  OwnerId?: number;
  /**
   * Permit access to the associated resource to any user
   * @example true
   */
  Public?: boolean;
  /**
   * Docker resource identifier on which access control will be applied.\
   * In the case of a resource control applied to a stack, use the stack name as identifier
   * @example "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"
   */
  ResourceId?: string;
  /**
   * List of Docker resources that will inherit this access control
   * @example ["617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"]
   */
  SubResourceIds?: string[];
  System?: boolean;
  TeamAccesses?: PortainereeTeamResourceAccess[];
  /**
   * Type of Docker resource. Valid values are: 1- container, 2 -service
   * 3 - volume, 4 - secret, 5 - stack, 6 - config or 7 - custom template
   * @example 1
   */
  Type?: number;
  UserAccesses?: PortainereeUserResourceAccess[];
}

export interface PortainereeRole {
  /** Authorizations associated to a role */
  Authorizations: PortainereeAuthorizations;
  /**
   * Role description
   * @example "Read-only access of all resources in an environment(endpoint)"
   */
  Description: string;
  /**
   * Role Identifier
   * @example 1
   */
  Id: number;
  /**
   * Role name
   * @example "HelpDesk"
   */
  Name: string;
  Priority: number;
}

export interface PortainereeS3BackupSettings {
  /** AWS access key id */
  accessKeyID?: string;
  /** AWS S3 bucket name */
  bucketName?: string;
  /** Crontab rule to make periodical backups */
  cronRule?: string;
  /** Password to encrypt the backup with */
  password?: string;
  /**
   * AWS S3 region. Default to "us-east-1"
   * @example "us-east-1"
   */
  region?: string;
  /** S3 compatible host */
  s3CompatibleHost?: string;
  /** AWS secret access key */
  secretAccessKey?: string;
}

export interface PortainereeSSLSettings {
  caCertPath?: string;
  certPath?: string;
  httpEnabled?: boolean;
  keyPath?: string;
  selfSigned?: boolean;
}

export interface PortainereeSettings {
  /** Container environment parameter AGENT_SECRET */
  AgentSecret?: string;
  AllowBindMountsForRegularUsers?: boolean;
  AllowContainerCapabilitiesForRegularUsers?: boolean;
  AllowDeviceMappingForRegularUsers?: boolean;
  AllowHostNamespaceForRegularUsers?: boolean;
  AllowPrivilegedModeForRegularUsers?: boolean;
  AllowStackManagementForRegularUsers?: boolean;
  AllowVolumeBrowserForRegularUsers?: boolean;
  /**
   * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
   * @example 1
   */
  AuthenticationMethod?: number;
  /** A list of label name & value that will be used to hide containers when querying containers */
  BlackListedLabels?: PortainereePair[];
  /** CloudAPIKeys */
  CloudApiKeys?: PortainereeCloudApiKeys;
  /** The content in plaintext used to display in the login page. Will hide when value is empty string */
  CustomLoginBanner?: string;
  Edge?: PortainereeEdge;
  /**
   * The default check in interval for edge agent (in seconds)
   * @example 5
   */
  EdgeAgentCheckinInterval?: number;
  /** EdgePortainerURL is the URL that is exposed to edge agents */
  EdgePortainerUrl?: string;
  /** Whether edge compute features are enabled */
  EnableEdgeComputeFeatures?: boolean;
  /** Deprecated fields v26 */
  EnableHostManagementFeatures?: boolean;
  /**
   * Whether telemetry is enabled
   * @example false
   */
  EnableTelemetry?: boolean;
  /**
   * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
   * @example false
   */
  EnforceEdgeID?: boolean;
  /** Experimental features */
  ExperimentalFeatures?: PortainereeExperimentalFeatures;
  /** Deployment options for encouraging git ops workflows */
  GlobalDeploymentOptions?: PortainereeGlobalDeploymentOptions;
  /**
   * Helm repository URL, defaults to "https://charts.bitnami.com/bitnami"
   * @example "https://charts.bitnami.com/bitnami"
   */
  HelmRepositoryURL?: string;
  InternalAuthSettings?: PortainereeInternalAuthSettings;
  /**
   * The expiry of a Kubeconfig
   * @example "24h"
   */
  KubeconfigExpiry?: string;
  /**
   * KubectlImage, defaults to portainer/kubectl-shell
   * @example "portainer/kubectl-shell"
   */
  KubectlShellImage?: string;
  LDAPSettings?: PortainereeLDAPSettings;
  /**
   * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
   * @example "https://mycompany.mydomain.tld/logo.png"
   */
  LogoURL?: string;
  OAuthSettings?: PortainereeOAuthSettings;
  /**
   * Show the Kompose build option (discontinued in 2.18)
   * @example false
   */
  ShowKomposeBuildOption?: boolean;
  /**
   * The interval in which environment(endpoint) snapshots are created
   * @example "5m"
   */
  SnapshotInterval?: string;
  /**
   * URL to the templates that will be displayed in the UI when navigating to App Templates
   * @example "https://raw.githubusercontent.com/portainer/templates/master/templates.json"
   */
  TemplatesURL?: string;
  /**
   * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
   * @example false
   */
  TrustOnFirstConnect?: boolean;
  /**
   * The duration of a user session
   * @example "5m"
   */
  UserSessionTimeout?: string;
  /** the default builtin registry now is anonymous docker hub registry */
  defaultRegistry?: {
    /** @example false */
    Hide?: boolean;
  };
  /** Deprecated fields */
  displayDonationHeader?: boolean;
  displayExternalContributors?: boolean;
  fdoConfiguration?: PortainereeFDOConfiguration;
  openAMTConfiguration?: PortainerOpenAMTConfiguration;
}

export interface PortainereeStack {
  /** Only applies when deploying stack with multiple files */
  AdditionalFiles?: string[];
  /** The auto update settings of a git stack */
  AutoUpdate?: PortainereeAutoUpdateSettings;
  /**
   * Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment
   * @example 1
   */
  EndpointId?: number;
  /**
   * Path to the Stack file
   * @example "docker-compose.yml"
   */
  EntryPoint?: string;
  /** A list of environment(endpoint) variables used during stack deployment */
  Env?: PortainereePair[];
  /**
   * Stack Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Stack name
   * @example "myStack"
   */
  Name?: string;
  /** The stack deployment option */
  Option?: PortainereeStackOption;
  ResourceControl?: PortainereeResourceControl;
  /**
   * Stack status (1 - active, 2 - inactive)
   * @example 1
   */
  Status?: number;
  /**
   * Cluster identifier of the Swarm cluster where the stack is deployed
   * @example "jpofkc0i9uo9wtx1zesuk649w"
   */
  SwarmId?: string;
  /**
   * Stack type. 1 for a Swarm stack, 2 for a Compose stack, 3 for a Kubernetes stack
   * @example 2
   */
  Type?: number;
  /**
   * The username which created this stack
   * @example "admin"
   */
  createdBy?: string;
  /**
   * The date in unix time when stack was created
   * @example 1587399600
   */
  creationDate?: number;
  /**
   * Network(Swarm) or local(Standalone) filesystem path
   * @example "/tmp"
   */
  filesystemPath?: string;
  /**
   * Whether the stack is from a app template
   * @example false
   */
  fromAppTemplate?: boolean;
  /** The git configuration of a git stack */
  gitConfig?: GittypesRepoConfig;
  /**
   * IsComposeFormat indicates if the Kubernetes stack is created from a Docker Compose file
   * @example false
   */
  isComposeFormat?: boolean;
  /**
   * Kubernetes namespace if stack is a kube application
   * @example "default"
   */
  namespace?: string;
  /**
   * Path on disk to the repository hosting the Stack file
   * @example "/data/compose/myStack_jpofkc0i9uo9wtx1zesuk649w"
   */
  projectPath?: string;
  /**
   * If stack support relative path volume
   * @example false
   */
  supportRelativePath?: boolean;
  /**
   * The date in unix time when stack was last updated
   * @example 1587399600
   */
  updateDate?: number;
  /**
   * The username which last updated this stack
   * @example "bob"
   */
  updatedBy?: string;
  /**
   * A UUID to identify a webhook. The stack will be force updated and pull the latest image when the webhook was invoked.
   * @example "c11fdf23-183e-428a-9bb6-16db01032174"
   */
  webhook?: string;
}

export interface PortainereeStackOption {
  /**
   * Prune services that are no longer referenced
   * @example false
   */
  prune?: boolean;
}

export interface PortainereeTLSConfiguration {
  /**
   * Use TLS
   * @example true
   */
  TLS?: boolean;
  /**
   * Path to the TLS CA certificate file
   * @example "/data/tls/ca.pem"
   */
  TLSCACert?: string;
  /**
   * Path to the TLS client certificate file
   * @example "/data/tls/cert.pem"
   */
  TLSCert?: string;
  /**
   * Path to the TLS client key file
   * @example "/data/tls/key.pem"
   */
  TLSKey?: string;
  /**
   * Skip the verification of the server TLS certificate
   * @example false
   */
  TLSSkipVerify?: boolean;
}

export interface PortainereeTag {
  /** A set of environment(endpoint) group ids that have this tag */
  EndpointGroups?: Record<string, boolean>;
  /** A set of environment(endpoint) ids that have this tag */
  Endpoints?: Record<string, boolean>;
  /**
   * Tag name
   * @example "org/acme"
   */
  Name?: string;
  /**
   * Tag identifier
   * @example 1
   */
  id?: number;
}

export interface PortainereeTeam {
  /**
   * Team Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Team name
   * @example "developers"
   */
  Name?: string;
}

export type PortainereeTeamAccessPolicies = Record<string, PortainereeAccessPolicy>;

export interface PortainereeTeamMembership {
  /**
   * Membership Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Team role (1 for team leader and 2 for team member)
   * @example 1
   */
  Role?: number;
  /**
   * Team identifier
   * @example 1
   */
  TeamID?: number;
  /**
   * User identifier
   * @example 1
   */
  UserID?: number;
}

export interface PortainereeTeamMemberships {
  AdminAutoPopulate?: boolean;
  AdminGroupClaimsRegexList?: string[];
  OAuthClaimMappings?: PortainereeOAuthClaimMappings[];
  OAuthClaimName?: string;
}

export interface PortainereeTeamResourceAccess {
  AccessLevel?: number;
  TeamId?: number;
}

export interface PortainereeTemplate {
  /**
   * Mandatory container/stack fields
   * Template Identifier
   * @example 1
   */
  Id?: number;
  /**
   * Whether the template should be available to administrators only
   * @example true
   */
  administrator_only?: boolean;
  /**
   * A list of categories associated to the template
   * @example ["database"]
   */
  categories?: string[];
  /**
   * The command that will be executed in a container template
   * @example "ls -lah"
   */
  command?: string;
  /**
   * Description of the template
   * @example "High performance web server"
   */
  description?: string;
  /** A list of environment(endpoint) variables used during the template deployment */
  env?: PortainereeTemplateEnv[];
  /**
   * Container hostname
   * @example "mycontainer"
   */
  hostname?: string;
  /**
   * Mandatory container fields
   * Image associated to a container template. Mandatory for a container template
   * @example "nginx:latest"
   */
  image?: string;
  /**
   * Whether the container should be started in
   * interactive mode (-i -t equivalent on the CLI)
   * @example true
   */
  interactive?: boolean;
  /** Container labels */
  labels?: PortainereePair[];
  /**
   * URL of the template's logo
   * @example "https://cloudinovasi.id/assets/img/logos/nginx.png"
   */
  logo?: string;
  /**
   * Optional stack/container fields
   * Default name for the stack/container to be used on deployment
   * @example "mystackname"
   */
  name?: string;
  /**
   * Name of a network that will be used on container deployment if it exists inside the environment(endpoint)
   * @example "mynet"
   */
  network?: string;
  /**
   * A note that will be displayed in the UI. Supports HTML content
   * @example "This is my <b>custom</b> template"
   */
  note?: string;
  /**
   * Platform associated to the template.
   * Valid values are: 'linux', 'windows' or leave empty for multi-platform
   * @example "linux"
   */
  platform?: string;
  /**
   * A list of ports exposed by the container
   * @example ["8080:80/tcp"]
   */
  ports?: string[];
  /**
   * Whether the container should be started in privileged mode
   * @example true
   */
  privileged?: boolean;
  /**
   * Optional container fields
   * The URL of a registry associated to the image for a container template
   * @example "quay.io"
   */
  registry?: string;
  /** Mandatory stack fields */
  repository?: PortainereeTemplateRepository;
  /**
   * Container restart policy
   * @example "on-failure"
   */
  restart_policy?: string;
  /**
   * Mandatory Edge stack fields
   * Stack file used for this template
   */
  stackFile?: string;
  /**
   * Title of the template
   * @example "Nginx"
   */
  title?: string;
  /**
   * Template type. Valid values are: 1 (container), 2 (Swarm stack) or 3 (Compose stack)
   * @example 1
   */
  type?: number;
  /** A list of volumes used during the container template deployment */
  volumes?: PortainereeTemplateVolume[];
}

export interface PortainereeTemplateEnv {
  /**
   * Default value that will be set for the variable
   * @example "default_value"
   */
  default?: string;
  /**
   * Content of the tooltip that will be generated in the UI
   * @example "MySQL root account password"
   */
  description?: string;
  /**
   * Text for the label that will be generated in the UI
   * @example "Root password"
   */
  label?: string;
  /**
   * name of the environment(endpoint) variable
   * @example "MYSQL_ROOT_PASSWORD"
   */
  name?: string;
  /**
   * If set to true, will not generate any input for this variable in the UI
   * @example false
   */
  preset?: boolean;
  /** A list of name/value that will be used to generate a dropdown in the UI */
  select?: PortainereeTemplateEnvSelect[];
}

export interface PortainereeTemplateEnvSelect {
  /**
   * Will set this choice as the default choice
   * @example false
   */
  default?: boolean;
  /**
   * Some text that will displayed as a choice
   * @example "text value"
   */
  text?: string;
  /**
   * A value that will be associated to the choice
   * @example "value"
   */
  value?: string;
}

export interface PortainereeTemplateRepository {
  /**
   * Path to the stack file inside the git repository
   * @example "./subfolder/docker-compose.yml"
   */
  stackfile?: string;
  /**
   * URL of a git repository used to deploy a stack template. Mandatory for a Swarm/Compose stack template
   * @example "https://github.com/portainer/portainer-compose"
   */
  url?: string;
}

export interface PortainereeTemplateVolume {
  /**
   * Path on the host
   * @example "/tmp"
   */
  bind?: string;
  /**
   * Path inside the container
   * @example "/data"
   */
  container?: string;
  /**
   * Whether the volume used should be readonly
   * @example true
   */
  readonly?: boolean;
}

export interface PortainereeUser {
  EndpointAuthorizations?: PortainereeEndpointAuthorizations;
  /**
   * User Identifier
   * @example 1
   */
  Id?: number;
  /**
   * OpenAI integration parameters
   * @example "sk-1234567890"
   */
  OpenAIApiKey?: string;
  PortainerAuthorizations?: PortainereeAuthorizations;
  /**
   * User role (1 for administrator account and 2 for regular account)
   * @example 1
   */
  Role?: number;
  /** @example 1639408208 */
  TokenIssueAt?: number;
  /** @example "bob" */
  Username?: string;
  themeSettings?: PortainereeUserThemeSettings;
  /**
   * Deprecated
   * @example "dark"
   */
  userTheme?: string;
}

export type PortainereeUserAccessPolicies = Record<string, PortainereeAccessPolicy>;

export interface PortainereeUserActivityLog {
  action?: string;
  context?: string;
  id?: number;
  payload?: number[];
  timestamp?: number;
  username?: string;
}

export interface PortainereeUserResourceAccess {
  AccessLevel?: number;
  /** User identifier who created this template */
  UserId?: number;
}

export interface PortainereeUserThemeSettings {
  /**
   * Color represents the color theme of the UI
   * @example "dark"
   */
  color?: "dark" | "light" | "highcontrast" | "auto";
  /** SubtleUpgradeButton indicates if the upgrade banner should be displayed in a subtle way */
  subtleUpgradeButton?: boolean;
}

export interface PortainereeWebhook {
  /** Environment(Endpoint) identifier. Reference the environment(endpoint) that will be used for deployment */
  EndpointId?: number;
  /**
   * Webhook Identifier
   * @example 1
   */
  Id?: number;
  /** Registry Identifier */
  RegistryId?: number;
  ResourceId?: string;
  Token?: string;
  Type?: number;
}

export interface ProvidersAmazonProvisionPayload {
  /** @example "BOTTLEROCKET_x86_64" */
  amiType: string;
  /**
   * CredentialID holds an ID of the credential used to create the cluster
   * @example 1
   */
  credentialID: number;
  /** @example "m5.large" */
  instanceType: string;
  /** @example "1.23" */
  kubernetesVersion: string;
  meta?: TypesEnvironmentMetadata;
  /** @example "myDevCluster" */
  name: string;
  /** @example "8465fb26-632e-4fa3-bb9b-21c449629026" */
  networkID?: string;
  /** @example 3 */
  nodeCount: number;
  /** @example "g3.small" */
  nodeSize: string;
  /** @example 20 */
  nodeVolumeSize?: number;
  /** @example "NYC1" */
  region: string;
}

export interface ProvidersAzureProvisionPayload {
  availabilityZones?: string[];
  /**
   * CredentialID holds an ID of the credential used to create the cluster
   * @example 1
   */
  credentialID: number;
  dnsPrefix?: string;
  /** @example "1.23" */
  kubernetesVersion: string;
  meta?: TypesEnvironmentMetadata;
  /** @example "myDevCluster" */
  name: string;
  /** @example "8465fb26-632e-4fa3-bb9b-21c449629026" */
  networkID?: string;
  /** @example 3 */
  nodeCount: number;
  /** @example "g3.small" */
  nodeSize: string;
  poolName?: string;
  /** @example "NYC1" */
  region: string;
  /** Azure specific fields */
  resourceGroup?: string;
  resourceGroupName?: string;
  tier?: string;
}

export interface ProvidersDefaultProvisionPayload {
  /**
   * CredentialID holds an ID of the credential used to create the cluster
   * @example 1
   */
  credentialID: number;
  /** @example "1.23" */
  kubernetesVersion: string;
  meta?: TypesEnvironmentMetadata;
  /** @example "myDevCluster" */
  name: string;
  /** @example "8465fb26-632e-4fa3-bb9b-21c449629026" */
  networkID?: string;
  /** @example 3 */
  nodeCount: number;
  /** @example "g3.small" */
  nodeSize: string;
  /** @example "NYC1" */
  region: string;
}

export interface ProvidersGKEProvisionPayload {
  /** @example 2 */
  cpu?: number;
  /**
   * CredentialID holds an ID of the credential used to create the cluster
   * @example 1
   */
  credentialID: number;
  /** @example 100 */
  hdd?: number;
  /** @example "1.23" */
  kubernetesVersion: string;
  meta?: TypesEnvironmentMetadata;
  /** @example "myDevCluster" */
  name: string;
  /** @example "8465fb26-632e-4fa3-bb9b-21c449629026" */
  networkID?: string;
  /** @example 3 */
  nodeCount: number;
  /** @example "g3.small" */
  nodeSize: string;
  /** @example 4 */
  ram?: number;
  /** @example "NYC1" */
  region: string;
}

export interface RegistriesDeleteTagsPayload {
  tags?: string[];
}

export interface RegistriesRegistryConfigurePayload {
  /**
   * Is authentication against this registry enabled
   * @example false
   */
  authentication: boolean;
  /**
   * Password used to authenticate against this registry. required when Authentication is true
   * @example "registry_password"
   */
  password?: string;
  /** ECR region */
  region?: string;
  /**
   * Use TLS
   * @example true
   */
  tls?: boolean;
  /** The TLS CA certificate file */
  tlscacertFile?: number[];
  /** The TLS client certificate file */
  tlscertFile?: number[];
  /** The TLS client key file */
  tlskeyFile?: number[];
  /**
   * Skip the verification of the server TLS certificate
   * @example false
   */
  tlsskipVerify?: boolean;
  /**
   * Username used to authenticate against this registry. Required when Authentication is true
   * @example "registry_user"
   */
  username?: string;
}

export interface RegistriesRegistryCreatePayload {
  /**
   * Is authentication against this registry enabled
   * @example false
   */
  authentication: boolean;
  /**
   * BaseURL required for ProGet registry
   * @example "registry.mydomain.tld:2375"
   */
  baseURL?: string;
  /** ECR specific details, required when type = 7 */
  ecr?: PortainereeEcrData;
  /** Github specific details, required when type = 8 */
  github?: PortainereeGithubRegistryData;
  /** Gitlab specific details, required when type = 4 */
  gitlab?: PortainereeGitlabRegistryData;
  /**
   * Name that will be used to identify this registry
   * @example "my-registry"
   */
  name: string;
  /**
   * Password used to authenticate against this registry. required when Authentication is true
   * @example "registry_password"
   */
  password?: string;
  /** Quay specific details, required when type = 1 */
  quay?: PortainereeQuayRegistryData;
  /**
   * Registry Type. Valid values are:
   * 	1 (Quay.io),
   * 	2 (Azure container registry),
   * 	3 (custom registry),
   * 	4 (Gitlab registry),
   * 	5 (ProGet registry),
   * 	6 (DockerHub)
   * 	7 (ECR)
   * 	8 (Github registry)
   * @example 1
   */
  type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
  /**
   * URL or IP address of the Docker registry
   * @example "registry.mydomain.tld:2375/feed"
   */
  url: string;
  /**
   * Username used to authenticate against this registry. Required when Authentication is true
   * @example "registry_user"
   */
  username?: string;
}

export interface RegistriesRegistryUpdatePayload {
  /** @example false */
  authentication: boolean;
  /** @example "registry.mydomain.tld:2375" */
  baseURL?: string;
  ecr?: PortainereeEcrData;
  github?: PortainereeGithubRegistryData;
  /** @example "my-registry" */
  name: string;
  /** @example "registry_password" */
  password?: string;
  quay?: PortainereeQuayRegistryData;
  registryAccesses?: PortainereeRegistryAccesses;
  /** @example "registry.mydomain.tld:2375/feed" */
  url: string;
  /** @example "registry_user" */
  username?: string;
}

export interface ReleaseChart {
  /**
   * Files are miscellaneous files in a chart archive,
   * e.g. README, LICENSE, etc.
   */
  files?: ReleaseFile[];
  /** Lock is the contents of Chart.lock. */
  lock?: ReleaseLock;
  /** Metadata is the contents of the Chartfile. */
  metadata?: ReleaseMetadata;
  /** Schema is an optional JSON schema for imposing structure on Values */
  schema?: number[];
  /** Templates for this chart. */
  templates?: ReleaseFile[];
  /** Values are default config for this chart. */
  values?: Record<string, any>;
}

export interface ReleaseDependency {
  /** Alias usable alias to be used for the chart */
  alias?: string;
  /** A yaml path that resolves to a boolean, used for enabling/disabling charts (e.g. subchart1.enabled ) */
  condition?: string;
  /** Enabled bool determines if chart should be loaded */
  enabled?: boolean;
  /**
   * ImportValues holds the mapping of source values to parent key to be imported. Each item can be a
   * string or pair of child/parent sublist items.
   */
  "import-values"?: any[];
  /**
   * Name is the name of the dependency.
   *
   * This must mach the name in the dependency's Chart.yaml.
   */
  name?: string;
  /**
   * The URL to the repository.
   *
   * Appending `index.yaml` to this string should result in a URL that can be
   * used to fetch the repository index.
   */
  repository?: string;
  /** Tags can be used to group charts for enabling/disabling together */
  tags?: string[];
  /**
   * Version is the version (range) of this chart.
   *
   * A lock file will always produce a single version, while a dependency
   * may contain a semantic version range.
   */
  version?: string;
}

export interface ReleaseFile {
  /** Data is the template as byte data. */
  data?: number[];
  /** Name is the path-like name of the template. */
  name?: string;
}

export interface ReleaseHook {
  /** DeletePolicies are the policies that indicate when to delete the hook */
  delete_policies?: string[];
  /** Events are the events that this hook fires on. */
  events?: string[];
  /** Kind is the Kubernetes kind. */
  kind?: string;
  /** LastRun indicates the date/time this was last run. */
  last_run?: ReleaseHookExecution;
  /** Manifest is the manifest contents. */
  manifest?: string;
  name?: string;
  /** Path is the chart-relative path to the template. */
  path?: string;
  /** Weight indicates the sort order for execution among similar Hook type */
  weight?: number;
}

export interface ReleaseHookExecution {
  /** CompletedAt indicates the date/time this hook was completed. */
  completed_at?: string;
  /** Phase indicates whether the hook completed successfully */
  phase?: string;
  /** StartedAt indicates the date/time this hook was started */
  started_at?: string;
}

export interface ReleaseLock {
  /** Dependencies is the list of dependencies that this lock file has locked. */
  dependencies?: ReleaseDependency[];
  /** Digest is a hash of the dependencies in Chart.yaml. */
  digest?: string;
  /** Generated is the date the lock file was last generated. */
  generated?: string;
}

export interface ReleaseMaintainer {
  /** Email is an optional email address to contact the named maintainer */
  email?: string;
  /** Name is a user name or organization name */
  name?: string;
  /** URL is an optional URL to an address for the named maintainer */
  url?: string;
}

export interface ReleaseMetadata {
  /**
   * Annotations are additional mappings uninterpreted by Helm,
   * made available for inspection by other applications.
   */
  annotations?: Record<string, string>;
  /** The API Version of this chart. Required. */
  apiVersion?: string;
  /** The version of the application enclosed inside of this chart. */
  appVersion?: string;
  /** The condition to check to enable chart */
  condition?: string;
  /** Dependencies are a list of dependencies for a chart. */
  dependencies?: ReleaseDependency[];
  /** Whether or not this chart is deprecated */
  deprecated?: boolean;
  /** A one-sentence description of the chart */
  description?: string;
  /** The URL to a relevant project page, git repo, or contact person */
  home?: string;
  /** The URL to an icon file. */
  icon?: string;
  /** A list of string keywords */
  keywords?: string[];
  /** KubeVersion is a SemVer constraint specifying the version of Kubernetes required. */
  kubeVersion?: string;
  /** A list of name and URL/email address combinations for the maintainer(s) */
  maintainers?: ReleaseMaintainer[];
  /** The name of the chart. Required. */
  name?: string;
  /** Source is the URL to the source code of this chart */
  sources?: string[];
  /** The tags to check to enable chart */
  tags?: string;
  /** Specifies the chart type: application or library */
  type?: string;
  /** A SemVer 2 conformant version string of the chart. Required. */
  version?: string;
}

export interface ReleaseRelease {
  /**
   * Info provides information about a release
   * Info *Info `json:"info,omitempty"`
   * Chart is the chart that was released.
   */
  chart?: ReleaseChart;
  /**
   * Config is the set of extra Values added to the chart.
   * These values override the default values inside of the chart.
   */
  config?: Record<string, any>;
  /** Hooks are all of the hooks declared for this release. */
  hooks?: ReleaseHook[];
  /** Manifest is the string representation of the rendered template. */
  manifest?: string;
  /** Name is the name of the release */
  name?: string;
  /** Namespace is the kubernetes namespace of the release. */
  namespace?: string;
  /** Version is an int which represents the revision of the release. */
  version?: number;
}

export interface ReleaseReleaseElement {
  app_version?: string;
  chart?: string;
  name?: string;
  namespace?: string;
  revision?: string;
  status?: string;
  updated?: string;
}

export interface ResourcecontrolsResourceControlCreatePayload {
  /**
   * Permit access to resource only to admins
   * @example true
   */
  administratorsOnly?: boolean;
  /**
   * Permit access to the associated resource to any user
   * @example true
   */
  public?: boolean;
  /** @example "617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08" */
  resourceID: string;
  /**
   * List of Docker resources that will inherit this access control
   * @example ["617c5f22bb9b023d6daab7cba43a57576f83492867bc767d1c59416b065e5f08"]
   */
  subResourceIDs?: string[];
  /**
   * List of team identifiers with access to the associated resource
   * @example [56,7]
   */
  teams?: number[];
  /**
   * Type of Resource. Valid values are: 1 - container, 2 - service
   * 3 - volume, 4 - network, 5 - secret, 6 - stack, 7 - config, 8 - custom template, 9 - azure-container-group
   * @example 1
   */
  type: 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9;
  /**
   * List of user identifiers with access to the associated resource
   * @example [1,4]
   */
  users?: number[];
}

export interface ResourcecontrolsResourceControlUpdatePayload {
  /**
   * Permit access to resource only to admins
   * @example true
   */
  administratorsOnly?: boolean;
  /**
   * Permit access to the associated resource to any user
   * @example true
   */
  public?: boolean;
  /**
   * List of team identifiers with access to the associated resource
   * @example [7]
   */
  teams?: number[];
  /**
   * List of user identifiers with access to the associated resource
   * @example [4]
   */
  users?: number[];
}

export interface SettingsDefaultRegistryUpdatePayload {
  /** @example false */
  Hide?: boolean;
}

export interface SettingsMTLSPayload {
  caCert?: string;
  cert?: string;
  key?: string;
  useSeparateCert?: boolean;
}

export interface SettingsPublicSettingsResponse {
  /**
   * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
   * @example 1
   */
  AuthenticationMethod?: number;
  /**
   * The content in plaintext used to display in the login page. Will hide when value is empty string
   * @example "notice or agreement"
   */
  CustomLoginBanner?: string;
  /**
   * Whether edge compute features are enabled
   * @example true
   */
  EnableEdgeComputeFeatures?: boolean;
  /**
   * Whether telemetry is enabled
   * @example true
   */
  EnableTelemetry?: boolean;
  /** Supported feature flags */
  Features?: Record<string, boolean>;
  /** Deployment options for encouraging deployment as code */
  GlobalDeploymentOptions?: PortainereeGlobalDeploymentOptions;
  /**
   * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
   * @example "https://mycompany.mydomain.tld/logo.png"
   */
  LogoURL?: string;
  /**
   * Whether portainer internal auth view will be hidden
   * @example true
   */
  OAuthHideInternalAuth?: boolean;
  /**
   * The URL used for oauth login
   * @example "https://gitlab.com/oauth"
   */
  OAuthLoginURI?: string;
  /**
   * The URL used for oauth logout
   * @example "https://gitlab.com/oauth/logout"
   */
  OAuthLogoutURI?: string;
  /**
   * The minimum required length for a password of any user when using internal auth mode
   * @example 1
   */
  RequiredPasswordLength?: number;
  /**
   * Show the Kompose build option (discontinued in 2.18)
   * @example false
   */
  ShowKomposeBuildOption?: boolean;
  /**
   * Whether team sync is enabled
   * @example true
   */
  TeamSync?: boolean;
  defaultRegistry?: {
    /** @example false */
    Hide?: boolean;
  };
  edge?: {
    /**
     * The command list interval for edge agent - used in edge async mode [seconds]
     * @example 60
     */
    CommandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode [seconds]
     * @example 60
     */
    PingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode [seconds]
     * @example 60
     */
    SnapshotInterval?: number;
    /**
     * The check in interval for edge agent (in seconds) - used in non async mode [seconds]
     * @example 60
     */
    checkinInterval?: number;
    mtls?: PortainereeMTLSSettings;
  };
  /** Whether AMT is enabled */
  isAMTEnabled?: boolean;
  /** Whether FDO is enabled */
  isFDOEnabled?: boolean;
  /**
   * The expiry of a Kubeconfig
   * @default "0"
   * @example "24h"
   */
  kubeconfigExpiry?: string;
}

export interface SettingsSettingsExperimentalInspectResponse {
  experimentalFeatures?: PortainereeExperimentalFeatures;
}

export interface SettingsSettingsExperimentalUpdatePayload {
  /**
   * OpenAI integration
   * @example true
   */
  openAIIntegration: boolean;
}

export interface SettingsSettingsUpdatePayload {
  /** EdgePortainerURL is the URL that is exposed to edge agents */
  EdgePortainerURL?: string;
  /**
   * Show the Kompose build option (discontinued in 2.18)
   * @example false
   */
  ShowKomposeBuildOption?: boolean;
  /**
   * Active authentication method for the Portainer instance. Valid values are: 1 for internal, 2 for LDAP, or 3 for oauth
   * @example 1
   */
  authenticationMethod?: number;
  /** A list of label name & value that will be used to hide containers when querying containers */
  blackListedLabels?: PortainereePair[];
  /**
   * The content in plaintext used to display in the login page. Will hide when value is empty string
   * @example "notice or agreement"
   */
  customLoginBanner?: string;
  edge?: {
    /**
     * The command list interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    CommandInterval?: number;
    /**
     * The ping interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    PingInterval?: number;
    /**
     * The snapshot interval for edge agent - used in edge async mode (in seconds)
     * @example 5
     */
    SnapshotInterval?: number;
    /** AsyncMode enables edge agent to run in async mode by default */
    asyncMode?: boolean;
    mtls?: SettingsMTLSPayload;
    /** The address where the tunneling server can be reached by Edge agents */
    tunnelServerAddress?: string;
  };
  /**
   * The default check in interval for edge agent (in seconds)
   * @example 5
   */
  edgeAgentCheckinInterval?: number;
  /**
   * Whether edge compute features are enabled
   * @example true
   */
  enableEdgeComputeFeatures?: boolean;
  /**
   * Whether telemetry is enabled
   * @example false
   */
  enableTelemetry?: boolean;
  /**
   * EnforceEdgeID makes Portainer store the Edge ID instead of accepting anyone
   * @example false
   */
  enforceEdgeID?: boolean;
  /** Deployment options for encouraging deployment as code */
  globalDeploymentOptions?: PortainereeGlobalDeploymentOptions;
  /**
   * Helm repository URL
   * @example "https://charts.bitnami.com/bitnami"
   */
  helmRepositoryURL?: string;
  internalAuthSettings?: PortainereeInternalAuthSettings;
  /**
   * The expiry of a Kubeconfig
   * @default "0"
   * @example "24h"
   */
  kubeconfigExpiry?: string;
  /**
   * Kubec	tl Shell Image Name/Tag
   * @example "portainer/kubectl-shell:latest"
   */
  kubectlShellImage?: string;
  ldapsettings?: PortainereeLDAPSettings;
  /**
   * URL to a logo that will be displayed on the login page as well as on top of the sidebar. Will use default Portainer logo when value is empty string
   * @example "https://mycompany.mydomain.tld/logo.png"
   */
  logoURL?: string;
  oauthSettings?: PortainereeOAuthSettings;
  /**
   * The interval in which environment(endpoint) snapshots are created
   * @example "5m"
   */
  snapshotInterval?: string;
  /**
   * URL to the templates that will be displayed in the UI when navigating to App Templates
   * @example "https://raw.githubusercontent.com/portainer/templates/master/templates.json"
   */
  templatesURL?: string;
  /**
   * TrustOnFirstConnect makes Portainer accepting edge agent connection by default
   * @example false
   */
  trustOnFirstConnect?: boolean;
  /**
   * The duration of a user session
   * @example "5m"
   */
  userSessionTimeout?: string;
}

export interface SslSslUpdatePayload {
  /** SSL Certficates */
  cert?: string;
  /** SSL Client Certificates */
  clientCert?: string;
  httpenabled?: boolean;
  key?: string;
}

export interface StacksComposeStackFromFileContentPayload {
  /** A list of environment(endpoint) variables used during stack deployment */
  env?: PortainereePair[];
  /**
   * Whether the stack is from a app template
   * @example false
   */
  fromAppTemplate?: boolean;
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Content of the Stack file
   * @example "version: 3
   *  services:
   *  web:
   *  image:nginx"
   */
  stackFileContent: string;
  /**
   * A UUID to identify a webhook. The stack will be force updated and pull the latest image when the webhook was invoked.
   * @example "c11fdf23-183e-428a-9bb6-16db01032174"
   */
  webhook?: string;
}

export interface StacksComposeStackFromGitRepositoryPayload {
  /**
   * Applicable when deploying with multiple stack files
   * @example ["[nz.compose.yml"," uat.compose.yml]"]
   */
  additionalFiles?: string[];
  /** Optional auto update configuration */
  autoUpdate?: PortainereeAutoUpdateSettings;
  /**
   * Path to the Stack file inside the Git repository
   * @default "docker-compose.yml"
   * @example "docker-compose.yml"
   */
  composeFile?: string;
  /** A list of environment(endpoint) variables used during stack deployment */
  env?: PortainereePair[];
  /**
   * Local filesystem path
   * @example "/tmp"
   */
  filesystemPath?: string;
  /**
   * Whether the stack is from a app template
   * @example false
   */
  fromAppTemplate?: boolean;
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Use basic authentication to clone the Git repository
   * @example true
   */
  repositoryAuthentication?: boolean;
  /**
   * GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication
   * is true and RepositoryUsername/RepositoryPassword are not provided
   * @example 0
   */
  repositoryGitCredentialID?: number;
  /**
   * Password used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitPassword"
   */
  repositoryPassword?: string;
  /**
   * Reference name of a Git repository hosting the Stack file
   * @example "refs/heads/master"
   */
  repositoryReferenceName?: string;
  /**
   * URL of a Git repository hosting the Stack file
   * @example "https://github.com/openfaas/faas"
   */
  repositoryURL: string;
  /**
   * Username used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitUsername"
   */
  repositoryUsername?: string;
  /**
   * Whether the stack supports relative path volume
   * @example false
   */
  supportRelativePath?: boolean;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
}

export interface StacksKubernetesGitDeploymentPayload {
  additionalFiles?: string[];
  autoUpdate?: PortainereeAutoUpdateSettings;
  composeFormat?: boolean;
  manifestFile?: string;
  namespace?: string;
  repositoryAuthentication?: boolean;
  repositoryGitCredentialID?: number;
  repositoryPassword?: string;
  repositoryReferenceName?: string;
  repositoryURL?: string;
  repositoryUsername?: string;
  stackName?: string;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
}

export interface StacksKubernetesManifestURLDeploymentPayload {
  composeFormat?: boolean;
  manifestURL?: string;
  namespace?: string;
  stackName?: string;
}

export interface StacksKubernetesStringDeploymentPayload {
  composeFormat?: boolean;
  namespace?: string;
  stackFileContent?: string;
  stackName?: string;
}

export interface StacksStackFileResponse {
  /**
   * Content of the Stack file
   * @example "version: 3
   *  services:
   *  web:
   *  image:nginx"
   */
  StackFileContent?: string;
}

export interface StacksStackGitRedployPayload {
  env?: PortainereePair[];
  /** @example false */
  prune?: boolean;
  /**
   * Force a pulling to current image with the original tag though the image is already the latest
   * @example false
   */
  pullImage?: boolean;
  repositoryAuthentication?: boolean;
  repositoryGitCredentialID?: number;
  repositoryPassword?: string;
  repositoryReferenceName?: string;
  repositoryUsername?: string;
}

export interface StacksStackGitUpdatePayload {
  autoUpdate?: PortainereeAutoUpdateSettings;
  env?: PortainereePair[];
  prune?: boolean;
  repositoryAuthentication?: boolean;
  repositoryGitCredentialID?: number;
  repositoryPassword?: string;
  repositoryReferenceName?: string;
  repositoryUsername?: string;
  tlsskipVerify?: boolean;
}

export interface StacksStackMigratePayload {
  /** @example 2 */
  endpointID: number;
  /** @example "new-stack" */
  name?: string;
  /** @example "jpofkc0i9uo9wtx1zesuk649w" */
  swarmID?: string;
}

export interface StacksSwarmStackFromFileContentPayload {
  /** A list of environment(endpoint) variables used during stack deployment */
  env?: PortainereePair[];
  /**
   * Whether the stack is from a app template
   * @example false
   */
  fromAppTemplate?: boolean;
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Content of the Stack file
   * @example "version: 3
   *  services:
   *  web:
   *  image:nginx"
   */
  stackFileContent: string;
  /**
   * Swarm cluster identifier
   * @example "jpofkc0i9uo9wtx1zesuk649w"
   */
  swarmID: string;
  /**
   * A UUID to identify a webhook. The stack will be force updated and pull the latest image when the webhook was invoked.
   * @example "c11fdf23-183e-428a-9bb6-16db01032174"
   */
  webhook?: string;
}

export interface StacksSwarmStackFromGitRepositoryPayload {
  /**
   * Applicable when deploying with multiple stack files
   * @example ["[nz.compose.yml"," uat.compose.yml]"]
   */
  additionalFiles?: string[];
  /** Optional auto update configuration */
  autoUpdate?: PortainereeAutoUpdateSettings;
  /**
   * Path to the Stack file inside the Git repository
   * @default "docker-compose.yml"
   * @example "docker-compose.yml"
   */
  composeFile?: string;
  /** A list of environment(endpoint) variables used during stack deployment */
  env?: PortainereePair[];
  /**
   * Network filesystem path
   * @example "/tmp"
   */
  filesystemPath?: string;
  /**
   * Whether the stack is from a app template
   * @example false
   */
  fromAppTemplate?: boolean;
  /**
   * Name of the stack
   * @example "myStack"
   */
  name: string;
  /**
   * Use basic authentication to clone the Git repository
   * @example true
   */
  repositoryAuthentication?: boolean;
  /**
   * GitCredentialID used to identify the bound git credential. Required when RepositoryAuthentication
   * is true and RepositoryUsername/RepositoryPassword are not provided
   * @example 0
   */
  repositoryGitCredentialID?: number;
  /**
   * Password used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitPassword"
   */
  repositoryPassword?: string;
  /**
   * Reference name of a Git repository hosting the Stack file
   * @example "refs/heads/master"
   */
  repositoryReferenceName?: string;
  /**
   * URL of a Git repository hosting the Stack file
   * @example "https://github.com/openfaas/faas"
   */
  repositoryURL: string;
  /**
   * Username used in basic authentication. Required when RepositoryAuthentication is true
   * and RepositoryGitCredentialID is 0
   * @example "myGitUsername"
   */
  repositoryUsername?: string;
  /**
   * Whether the stack suppors relative path volume
   * @example false
   */
  supportRelativePath?: boolean;
  /**
   * Swarm cluster identifier
   * @example "jpofkc0i9uo9wtx1zesuk649w"
   */
  swarmID: string;
  /**
   * TLSSkipVerify skips SSL verification when cloning the Git repository
   * @example false
   */
  tlsskipVerify?: boolean;
}

export interface StacksUpdateSwarmStackPayload {
  /** A list of environment(endpoint) variables used during stack deployment */
  env?: PortainereePair[];
  /**
   * Prune services that are no longer referenced (only available for Swarm stacks)
   * @example true
   */
  prune?: boolean;
  /**
   * Force a pulling to current image with the original tag though the image is already the latest
   * @example false
   */
  pullImage?: boolean;
  /**
   * New content of the Stack file
   * @example "version: 3
   *  services:
   *  web:
   *  image:nginx"
   */
  stackFileContent?: string;
  /**
   * A UUID to identify a webhook. The stack will be force updated and pull the latest image when the webhook was invoked.
   * @example "c11fdf23-183e-428a-9bb6-16db01032174"
   */
  webhook?: string;
}

export interface SystemSystemInfoResponse {
  agents?: number;
  edgeAgents?: number;
  platform?: string;
}

export interface TagsTagCreatePayload {
  /**
   * Name
   * @example "org/acme"
   */
  name: string;
}

export interface TeammembershipsTeamMembershipCreatePayload {
  /**
   * Role for the user inside the team (1 for leader and 2 for regular member)
   * @example 1
   */
  role: 1 | 2;
  /**
   * Team identifier
   * @example 1
   */
  teamID: number;
  /**
   * User identifier
   * @example 1
   */
  userID: number;
}

export interface TeammembershipsTeamMembershipUpdatePayload {
  /**
   * Role for the user inside the team (1 for leader and 2 for regular member)
   * @example 1
   */
  role: 1 | 2;
  /**
   * Team identifier
   * @example 1
   */
  teamID: number;
  /**
   * User identifier
   * @example 1
   */
  userID: number;
}

export interface TeamsTeamCreatePayload {
  /**
   * Name
   * @example "developers"
   */
  name: string;
  /**
   * TeamLeaders
   * @example [3,5]
   */
  teamLeaders?: number[];
}

export interface TeamsTeamUpdatePayload {
  /**
   * Name
   * @example "developers"
   */
  name?: string;
}

export interface TemplatesFilePayload {
  /**
   * Path to the file inside the git repository
   * @example "./subfolder/docker-compose.yml"
   */
  composeFilePathInRepository: string;
  /**
   * URL of a git repository where the file is stored
   * @example "https://github.com/portainer/portainer-compose"
   */
  repositoryURL: string;
}

export interface TemplatesFileResponse {
  /**
   * The requested file content
   * @example "version:2"
   */
  fileContent?: string;
}

export interface TemplatesListResponse {
  templates?: PortainereeTemplate[];
  version?: string;
}

export interface TypesEndpointUpdateScheduleRelation {
  /** EdgeStack Identifier */
  edgeStackId?: number;
  environmentId?: number;
  scheduleId?: number;
  targetVersion?: string;
}

export interface TypesEnvironmentMetadata {
  /** Environment(Endpoint) group identifier */
  groupId?: number;
  tagIds?: number[];
}

export interface TypesMountPoint {
  /**
   * Destination is the path relative to the container root (`/`) where the
   * Source is mounted inside the container.
   */
  destination?: string;
  /** Driver is the volume driver used to create the volume (if it is a volume). */
  driver?: string;
  /**
   * Mode is a comma separated list of options supplied by the user when
   * creating the bind/volume mount.
   *
   * The default is platform-specific (`"z"` on Linux, empty on Windows).
   */
  mode?: string;
  /**
   * Name is the name reference to the underlying data defined by `Source`
   * e.g., the volume name.
   */
  name?: string;
  /**
   * Propagation describes how mounts are propagated from the host into the
   * mount point, and vice-versa. Refer to the Linux kernel documentation
   * for details:
   * https://www.kernel.org/doc/Documentation/filesystems/sharedsubtree.txt
   *
   * This field is not used on Windows.
   */
  propagation?: string;
  /** RW indicates whether the mount is mounted writable (read-write). */
  rw?: boolean;
  /**
   * Source is the source location of the mount.
   *
   * For volumes, this contains the storage location of the volume (within
   * `/var/lib/docker/volumes/`). For bind-mounts, and `npipe`, this contains
   * the source (host) part of the bind-mount. For `tmpfs` mount points, this
   * field is empty.
   */
  source?: string;
  /**
   * Type is the type of mount, see `Type<foo>` definitions in
   * github.com/docker/docker/api/types/mount.Type
   */
  type?: string;
}

export interface TypesPort {
  /** Host IP address that the container's port is mapped to */
  IP?: string;
  /**
   * Port on the container
   * Required: true
   */
  PrivatePort?: number;
  /** Port exposed on the host */
  PublicPort?: number;
  /**
   * type
   * Required: true
   */
  Type?: string;
}

export interface TypesServiceUpdateResponse {
  /** Optional warning messages */
  Warnings?: string[];
}

export interface TypesSummaryNetworkSettings {
  networks?: Record<string, NetworkEndpointSettings>;
}

export interface TypesUpdateSchedule {
  /**
   * Created timestamp
   * @example 1564897200
   */
  created?: number;
  /**
   * Created by user id
   * @example 1
   */
  createdBy?: number;
  /**
   * EdgeStack Identifier
   * @example 1
   */
  edgeStackId?: number;
  environmentsPreviousVersions?: Record<string, string>;
  /**
   * EdgeUpdateSchedule Identifier
   * @example 1
   */
  id?: number;
  /**
   * Name of the schedule
   * @example "Update Schedule"
   */
  name?: string;
  /**
   * ID of registry
   * @example 1
   */
  registryId?: number;
  /**
   * Type of the update (1 - update, 2 - rollback)
   * @example 1
   */
  type?: 1 | 2;
  /** @example "1.0.0" */
  version?: string;
}

export interface UseractivityLogsListResponse {
  logs?: PortainereeUserActivityLog[];
  totalCount?: number;
}

export interface UsersAccessTokenResponse {
  apiKey?: PortainereeAPIKey;
  rawAPIKey?: string;
}

export interface UsersAdminInitPayload {
  /**
   * Password for the admin user
   * @example "admin-password"
   */
  password: string;
  /**
   * Username for the admin user
   * @example "admin"
   */
  username: string;
}

export interface UsersGitCredentialResponse {
  gitCredential?: PortainereeGitCredential;
}

export type UsersNamespaceMapping = Record<string, Record<string, PortainereeAuthorizations>>;

export interface UsersThemePayload {
  /**
   * Color represents the color theme of the UI
   * @example "dark"
   */
  color?: "dark" | "light" | "highcontrast" | "auto";
  /**
   * SubtleUpgradeButton indicates if the upgrade banner should be displayed in a subtle way
   * @example false
   */
  subtleUpgradeButton?: boolean;
}

export interface UsersUserAccessTokenCreatePayload {
  /** @example "github-api-key" */
  description: string;
}

export interface UsersUserCreatePayload {
  /** @example "cg9Wgky3" */
  password: string;
  /**
   * User role (1 for administrator account and 2 for regular account)
   * @example 2
   */
  role: 1 | 2;
  /** @example "bob" */
  username: string;
}

export interface UsersUserGitCredentialCreatePayload {
  /** @example "my-credential" */
  name: string;
  password: string;
  username: string;
}

export interface UsersUserUpdateOpenAIConfigPayload {
  /**
   * ApiKey is the OpenAI API key that will be used to interact with the OpenAI API.
   * @example "sk-1234567890"
   */
  apiKey: string;
}

export interface UsersUserUpdatePasswordPayload {
  /**
   * New Password
   * @example "new_passwd"
   */
  newPassword: string;
  /**
   * Current Password
   * @example "passwd"
   */
  password: string;
}

export interface UsersUserUpdatePayload {
  /** @example "cg9Wgky3" */
  password: string;
  /**
   * User role (1 for administrator account and 2 for regular account)
   * @example 2
   */
  role: 1 | 2;
  theme?: UsersThemePayload;
  /** @example "bob" */
  username: string;
}

export interface WebhooksWebhookCreatePayload {
  endpointID?: number;
  /**
   * Registry Identifier
   * @example 1
   */
  registryID?: number;
  resourceID?: string;
  webhookType?: number;
}

export interface WebhooksWebhookReassignPayload {
  resourceID?: string;
  webhookType?: number;
}

export interface WebhooksWebhookUpdatePayload {
  /** Registry Identifier */
  registryID?: number;
}

export type AuthenticateUserData = AuthAuthenticateResponse;

export type LogoutData = any;

export type ValidateOAuthData = AuthAuthenticateResponse;

export type BackupData = any;

export type BackupToS3Data = any;

export type RestoreFromS3Data = any;

export type BackupSettingsFetchData = PortainereeS3BackupSettings;

export type UpdateS3SettingsData = any;

export type BackupStatusFetchData = BackupBackupStatus;

export type ChatQueryData = ChatChatQueryResponse;

export type ProvisionKaaSClusterData = PortainereeEndpoint;

export interface KaasProviderInfoParams {
  /** If true, get the up-to-date information (instead of cached information). */
  force?: boolean;
  /** The shared credential ID used to fetch the cloud provider information. */
  credentialId: number;
  provider: string;
}

export type KaasProviderInfoData = any;

export interface Microk8SAddonsParams {
  /** The environment ID of the cluster within Portainer. */
  environmentID: number;
  /** The credential ID to use to connect to a node in the MicroK8s cluster. */
  credentialID: number;
}

export type Microk8SAddonsData = any;

export interface GetByIdParams {
  /** ID of the cloud credential */
  id: string;
}

export type GetByIdData = ModelsCloudCredential;

export interface DeleteParams {
  /** ID of the cloud credential */
  id: string;
}

export type DeleteData = ModelsCloudCredential;

export interface UpdatePayload {
  /** cloud provider such as aws, aks, civo, digitalocean, etc. */
  provider: string;
  /** name of the credentials such as rnd-test-credential */
  name: string;
  /** credentials in json format */
  credentials: string;
}

export type UpdateData = ModelsCloudCredential;

export interface CustomTemplateListParams {
  /** Template types */
  type: (1 | 2 | 3)[];
}

export type CustomTemplateListData = PortainereeCustomTemplate[];

export interface CustomTemplateCreatePayload {
  /** Title of the template. required when method is file */
  Title?: string;
  /** Description of the template. required when method is file */
  Description?: string;
  /** A note that will be displayed in the UI. Supports HTML content */
  Note?: string;
  /** Platform associated to the template (1 - 'linux', 2 - 'windows'). required when method is file */
  Platform?: 1 | 2;
  /** Type of created stack (1 - swarm, 2 - compose), required when method is file */
  Type?: 1 | 2;
  /** required when method is file */
  file?: File;
}

export interface CustomTemplateCreateParams {
  /** method for creating template */
  method: "string" | "file" | "repository";
}

export type CustomTemplateCreateData = PortainereeCustomTemplate;

export type CustomTemplateDeleteData = any;

export type CustomTemplateInspectData = PortainereeCustomTemplate;

export type CustomTemplateUpdateData = PortainereeCustomTemplate;

export type CustomTemplateFileData = CustomtemplatesFileResponse;

export type ContainerImageStatusData = any;

export type DockerContainerGpusInspectData = ContainersContainerGpusResponse;

export type ServiceImageStatusData = any;

export type SnapshotInspectData = PortainerDockerSnapshotRaw;

export interface SnapshotContainersListParams {
  /** Edge stack identifier, will return only containers for this edge stack */
  edgeStackId?: number;
  /** Environment identifier */
  environmentId: number;
}

export type SnapshotContainersListData = PortainerDockerContainerSnapshot;

export type SnapshotContainerInspectData = PortainerDockerContainerSnapshot;

export type StackImagesStatusData = any;

export type EdgeGroupListData = EdgegroupsDecoratedEdgeGroup[];

export type EdgeGroupCreateData = PortainereeEdgeGroup;

export type EdgeGroupDeleteData = any;

export type EdgeGroupInspectData = PortainereeEdgeGroup;

export type EgeGroupUpdateData = PortainereeEdgeGroup;

export type EdgeJobListData = PortainereeEdgeJob[];

export interface EdgeJobCreateParams {
  /** Creation Method */
  method: "file" | "string";
}

export type EdgeJobCreateData = PortainereeEdgeGroup;

export type EdgeJobDeleteData = any;

export type EdgeJobInspectData = PortainereeEdgeJob;

export type EdgeJobUpdateData = PortainereeEdgeJob;

export type EdgeJobFileData = EdgejobsEdgeJobFileResponse;

export type EdgeJobTasksListData = EdgejobsTaskContainer[];

export type EdgeJobTasksClearData = any;

export type EdgeJobTaskLogsInspectData = EdgejobsFileResponse;

export type EdgeJobTasksCollectData = any;

export type EdgeStackListData = PortainereeEdgeStack[];

export interface EdgeStackCreateParams {
  /** Creation Method */
  method: "file" | "string" | "repository";
}

export type EdgeStackCreateData = PortainereeEdgeStack;

export type EdgeStackDeleteData = any;

export type EdgeStackInspectData = PortainereeEdgeStack;

export type EdgeStackUpdateData = PortainereeEdgeStack;

export type EdgeStackFileData = EdgestacksStackFileResponse;

export type EdgeStackLogsDeleteData = any;

export type EdgeStackLogsStatusGetData = any;

export interface EdgeStackLogsCollectParams {
  /** Number of lines to request for the logs */
  tail?: number;
  /** EdgeStack Id */
  id: number;
  /** Environment Id */
  endpointId: number;
}

export type EdgeStackLogsCollectData = any;

export type EdgeStackStatusUpdateData = PortainereeEdgeStack;

export type EdgeStackStatusDeleteData = PortainereeEdgeStack;

export type EdgeTemplateListData = PortainereeTemplate[];

export type EdgeUpdateScheduleListData = EdgeupdateschedulesDecoratedUpdateSchedule[];

export type EdgeUpdateScheduleUpdateData = any;

export type EdgeUpdateScheduleDeleteData = any;

export type EdgeUpdateScheduleInspectData = EdgeupdateschedulesDecoratedUpdateSchedule;

export type EdgeUpdateScheduleActiveSchedulesListData = TypesEndpointUpdateScheduleRelation[];

export type AgentVersionsData = string[];

export type EdgeUpdatePreviousVersionsData = string[];

export type EndpointGroupListData = PortainereeEndpointGroup[];

export type EndpointGroupsCreateData = PortainereeEndpointGroup;

export type EndpointGroupDeleteData = any;

export type EndpointGroupsDetailData = PortainereeEndpointGroup;

export type EndpointGroupUpdateData = PortainereeEndpointGroup;

export type EndpointGroupDeleteEndpointData = any;

export type EndpointGroupAddEndpointData = any;

export interface EndpointListParams {
  /** Start searching from */
  start?: number;
  /** Limit results to this value */
  limit?: number;
  /** Sort results by this value */
  sort?: number;
  /** Order sorted results by desc/asc */
  order?: number;
  /** Search query */
  search?: string;
  /** List environments(endpoints) of these groups */
  groupIds?: number[];
  /** List environments(endpoints) by this status */
  status?: number[];
  /** List environments(endpoints) of this type */
  types?: number[];
  /** search environments(endpoints) with these tags (depends on tagsPartialMatch) */
  tagIds?: number[];
  /** If true, will return environment(endpoint) which has one of tagIds, if false (or missing) will return only environments(endpoints) that has all the tags */
  tagsPartialMatch?: boolean;
  /** will return only these environments(endpoints) */
  endpointIds?: number[];
  /** If true, will return environment(endpoint) that were provisioned */
  provisioned?: boolean;
  /** will return only environments with on of these agent versions */
  agentVersions?: string[];
  /** if exists true show only edge async agents, false show only standard edge agents. if missing, will show both types (relevant only for edge agents) */
  edgeAsync?: boolean;
  /** if true, show only untrusted edge agents, if false show only trusted edge agents (relevant only for edge agents) */
  edgeDeviceUntrusted?: boolean;
  /** will return only environments(endpoints) with this name */
  name?: string;
}

export type EndpointListData = PortainereeEndpoint[];

export interface EndpointCreatePayload {
  /** Name that will be used to identify this environment(endpoint) (example: my-environment) */
  Name: string;
  /** Environment(Endpoint) type. Value must be one of: 1 (Local Docker environment), 2 (Agent environment), 3 (Azure environment), 4 (Edge agent environment) or 5 (Local Kubernetes Environment) */
  EndpointCreationType: number;
  /** URL or IP address of a Docker host (example: docker.mydomain.tld:2375). Defaults to local if not specified (Linux: /var/run/docker.sock, Windows: //./pipe/docker_engine). Cannot be empty if EndpointCreationType is set to 4 (Edge agent environment) */
  URL?: string;
  /** URL or IP address where exposed containers will be reachable. Defaults to URL if not specified (example: docker.mydomain.tld:2375) */
  PublicURL?: string;
  /** Environment(Endpoint) group identifier. If not specified will default to 1 (unassigned). */
  GroupID?: number;
  /** Require TLS to connect against this environment(endpoint). Must be true if EndpointCreationType is set to 2 (Agent environment) */
  TLS?: boolean;
  /** Skip server verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment) */
  TLSSkipVerify?: boolean;
  /** Skip client verification when using TLS. Must be true if EndpointCreationType is set to 2 (Agent environment) */
  TLSSkipClientVerify?: boolean;
  /**
   * TLS CA certificate file
   * @format binary
   */
  TLSCACertFile?: File;
  /**
   * TLS client certificate file
   * @format binary
   */
  TLSCertFile?: File;
  /**
   * TLS client key file
   * @format binary
   */
  TLSKeyFile?: File;
  /** Azure application ID. Required if environment(endpoint) type is set to 3 */
  AzureApplicationID?: string;
  /** Azure tenant ID. Required if environment(endpoint) type is set to 3 */
  AzureTenantID?: string;
  /** Azure authentication key. Required if environment(endpoint) type is set to 3 */
  AzureAuthenticationKey?: string;
  /** List of tag identifiers to which this environment(endpoint) is associated */
  TagIds?: number[];
  /** The check in interval for edge agent (in seconds) */
  EdgeCheckinInterval?: number;
  /** URL or IP address that will be used to establish a reverse tunnel */
  EdgeTunnelServerAddress: string;
  /** Enable async mode for edge agent */
  EdgeAsyncMode?: boolean;
  /** List of GPUs */
  Gpus?: any[];
}

export type EndpointCreateData = PortainereeEndpoint;

export type EndpointDeleteData = any;

export type EndpointInspectData = PortainereeEndpoint;

export type EndpointUpdateData = PortainereeEndpoint;

export type EndpointAssociationDeleteData = PortainereeEndpoint;

export interface DockerV2BrowsePutCreatePayload {
  /** The destination path to upload the file to */
  Path: string;
  /** The file to upload */
  file: File;
}

export interface DockerV2BrowsePutCreateParams {
  /** Optional volume identifier to upload the file */
  volumeID?: string;
  /** Environment(Endpoint) identifier */
  id: number;
}

export type DockerV2BrowsePutCreateData = any;

export type EndpointDockerhubStatusData = EndpointsDockerhubStatusResponse;

export type EdgeGenerateKeyDetailData = any;

export type EdgeJobsLogsCreateData = any;

export type EdgeStacksDetailData = EndpointedgeConfigResponse;

export type EndpointEdgeStatusInspectData = EndpointedgeEndpointEdgeStatusInspectResponse;

export type EdgeTrustCreateData = any;

export type EndpointForceUpdateServiceData = TypesServiceUpdateResponse;

export interface HelmListParams {
  /** specify an optional namespace */
  namespace?: string;
  /** specify an optional filter */
  filter?: string;
  /** specify an optional selector */
  selector?: string;
  /** Environment(Endpoint) identifier */
  id: number;
}

export type HelmListData = ReleaseReleaseElement[];

export type HelmInstallData = ReleaseRelease;

export interface HelmDeleteParams {
  /** An optional namespace */
  namespace?: string;
  /** Environment(Endpoint) identifier */
  id: number;
  /** The name of the release/application to uninstall */
  release: string;
}

export type HelmDeleteData = any;

export type HelmUserRepositoriesListData = HelmHelmUserRepositoryResponse;

export type HelmUserRepositoryCreateData = PortainereeHelmUserRepository;

export type EndpointPoolsAccessUpdateData = any;

export interface EndpointRegistriesListParams {
  /** required if kubernetes environment, will show registries by namespace */
  namespace?: string;
  /** Environment(Endpoint) identifier */
  id: number;
}

export type EndpointRegistriesListData = PortainereeRegistry[];

export type EndpointRegistryAccessData = any;

export type EndpointSettingsUpdateData = PortainereeEndpoint;

export type EndpointSnapshotData = any;

export type EndpointEdgeAsyncData = EndpointedgeEdgeAsyncResponse;

export type EndpointCreateGlobalKeyData = EndpointsEndpointCreateGlobalKeyResponse;

export type EndpointSnapshotsData = any;

export type FdoConfigureData = any;

export type FdoConfigureDeviceData = any;

export type FdoListAllData = any;

export type FdoProfileListData = any;

export type CreateProfileData = any;

export type DeleteProfileData = any;

export type FdoProfileInspectData = any;

export type UpdateProfileData = any;

export type DuplicateData = any;

export type FdoRegisterDeviceData = any;

export interface GitOperationRepoFilesSearchParams {
  /** list the results without using cache */
  force?: boolean;
}

export type GitOperationRepoFilesSearchData = string[];

export interface GitOperationRepoRefsParams {
  /** list the results without using cache */
  force?: boolean;
}

export type GitOperationRepoRefsData = string[];

export type UpdateK8SPodSecurityRuleData = any;

export interface GetKubernetesApplicationsParams {
  namespace: string;
  /** Environment(Endpoint) identifier */
  id: number;
}

export type GetKubernetesApplicationsData = ModelsK8SApplication[];

export interface GetKubernetesApplicationParams {
  /** specify true to perform a rolling restart of the application */
  "rollout-restart": string;
  /** Environment(Endpoint) identifier */
  id: number;
  /** The namespace */
  namespace: string;
  /** deployment, statefulset or daemonset */
  kind: string;
  /** name of the application */
  name: string;
}

export type GetKubernetesApplicationData = ModelsK8SApplication;

export type KubernetesNamespacesToggleSystemData = any;

export type GetKubernetesNodesLimitsData = PortainereeK8SNodesLimits;

export type GetKubernetesPodSecurityRuleData = PodsecurityPodSecurityRule;

export type IsRbacEnabledData = any;

export interface GetKubernetesConfigParams {
  /** will include only these environments(endpoints) */
  ids?: number[];
  /** will exclude these environments(endpoints) */
  excludeIds?: number[];
}

export type GetKubernetesConfigData = any;

export type LdapAdminGroupsData = string[];

export type LdapCheckData = any;

export type LdapGroupsData = PortainereeLDAPUser[];

export type LdapTestLoginData = LdapTestLoginResponse;

export type LdapUsersData = PortainereeLDAPUser[];

export type LicensesListData = LiblicensePortainerLicense[];

export interface LicensesAttachParams {
  /** remove conflicting licenses */
  force?: boolean;
}

export type LicensesAttachData = LicensesAttachResponse;

export type LicensesInfoData = LicensesLicenseInfo;

export type LicensesDeleteData = any;

export type MotdData = MotdMotdResponse;

export type GetTaskEventsData = NomadSlimNomadTaskEvent[];

export type GetTaskLogsData = NomadSlimNomadTaskEvent[];

export type GetDashboardData = any;

export type ListJobsData = any;

export type DeleteJobData = any;

export type GetLeaderData = any;

export type OpenAmtConfigureData = any;

export type OpenAmtActivateData = any;

export type OpenAmtDevicesData = any;

export type DeviceActionData = any;

export type DeviceFeaturesData = any;

export type OpenAmtHostInfoData = any;

export type RegistryListData = PortainereeRegistry[];

export type RegistryCreateData = PortainereeRegistry;

export type RegistryDeleteData = any;

export type RegistryInspectData = PortainereeRegistry;

export type RegistryUpdateData = PortainereeRegistry;

export type RegistryConfigureData = any;

export type EcrDeleteRepositoryData = any;

export type EcrDeleteTagsData = any;

export type ResourceControlCreateData = PortainereeResourceControl;

export type ResourceControlDeleteData = any;

export type ResourceControlUpdateData = PortainereeResourceControl;

export type RestoreData = any;

export type RoleListData = PortainereeRole[];

export type SettingsInspectData = PortainereeSettings;

export type SettingsUpdateData = PortainereeSettings;

export type SettingsExperimentalInspectData = SettingsSettingsExperimentalInspectResponse;

export type SettingsExperimentalUpdateData = any;

export type SettingsPublicData = SettingsPublicSettingsResponse;

export type GenerateData = ModelsSSHKeyPair;

export type SslInspectData = PortainereeSSLSettings;

export type SslUpdateData = any;

export interface StackListParams {
  /** Filters to process on the stack list. Encoded as JSON (a map[string]string). For example, {'SwarmID': 'jpofkc0i9uo9wtx1zesuk649w'} will only return stacks that are part of the specified Swarm cluster. Available filters: EndpointID, SwarmID. */
  filters?: string;
}

export type StackListData = PortainereeStack[];

export interface StackCreatePayload {
  /** Name of the stack. required when method is file */
  Name?: string;
  /** Swarm cluster identifier. Required when method equals file and type equals 1. required when method is file */
  SwarmID?: string;
  /** Environment(Endpoint) variables passed during deployment, represented as a JSON array [{'name': 'name', 'value': 'value'}]. Optional, used when method equals file and type equals 1. */
  Env?: string;
  /** Stack file. required when method is file */
  file?: File;
}

export interface StackCreateParams {
  /** Stack deployment type. Possible values: 1 (Swarm stack), 2 (Compose stack) or 3 (Kubernetes stack). */
  type: 1 | 2 | 3;
  /** Stack deployment method. Possible values: file, string, repository or url. */
  method: "string" | "file" | "repository" | "url";
  /** Identifier of the environment(endpoint) that will be used to deploy the stack */
  endpointId: number;
}

export type StackCreateData = PortainereeStack;

export interface StackDeleteParams {
  /** Set to true to delete an external stack. Only external Swarm stacks are supported */
  external?: boolean;
  /** Environment(Endpoint) identifier used to remove an external stack (required when external is set to true) */
  endpointId?: number;
  /** Stack identifier */
  id: number;
}

export type StackDeleteData = any;

export type StackInspectData = PortainereeStack;

export interface StackUpdateParams {
  /** Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
  endpointId?: number;
  /** Stack identifier */
  id: number;
}

export type StackUpdateData = PortainereeStack;

export interface StackAssociateParams {
  /** Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
  endpointId: number;
  /** Swarm identifier */
  swarmId: number;
  /** Indicates whether the stack is orphaned */
  orphanedRunning: boolean;
  /** Stack identifier */
  id: number;
}

export type StackAssociateData = PortainereeStack;

export type StackFileInspectData = StacksStackFileResponse;

export interface StackUpdateGitParams {
  /** Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
  endpointId?: number;
  /** Stack identifier */
  id: number;
}

export type StackUpdateGitData = PortainereeStack;

export interface StackGitRedeployParams {
  /** Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
  endpointId?: number;
  /** Stack identifier */
  id: number;
}

export type StackGitRedeployData = PortainereeStack;

export interface StackMigrateParams {
  /** Stacks created before version 1.18.0 might not have an associated environment(endpoint) identifier. Use this optional parameter to set the environment(endpoint) identifier used by the stack. */
  endpointId?: number;
  /** Stack identifier */
  id: number;
}

export type StackMigrateData = PortainereeStack;

export type StackStartData = PortainereeStack;

export type StackStopData = PortainereeStack;

export type WebhookInvokeData = any;

export type StatusInspectData = GithubComPortainerPortainerEeApiHttpHandlerSystemStatus;

export type StatusNodesCountData = GithubComPortainerPortainerEeApiHttpHandlerSystemNodesCountResponse;

export type VersionData = GithubComPortainerPortainerEeApiHttpHandlerSystemVersionResponse;

export type SystemInfoData = SystemSystemInfoResponse;

export type SystemNodesCountData = GithubComPortainerPortainerEeApiHttpHandlerSystemNodesCountResponse;

export type SystemStatusData = GithubComPortainerPortainerEeApiHttpHandlerSystemStatus;

export type SystemUpgradeData = GithubComPortainerPortainerApiHttpHandlerSystemStatus;

export type SystemVersionData = GithubComPortainerPortainerEeApiHttpHandlerSystemVersionResponse;

export type TagListData = PortainereeTag[];

export type TagCreateData = PortainereeTag;

export type TagDeleteData = any;

export type TeamMembershipListData = PortainereeTeamMembership[];

export type TeamMembershipCreateData = PortainereeTeamMembership;

export type TeamMembershipDeleteData = any;

export type TeamMembershipUpdateData = PortainereeTeamMembership;

export interface TeamListParams {
  /** Only list teams that the user is leader of */
  onlyLedTeams?: boolean;
  /** Identifier of the environment(endpoint) that will be used to filter the authorized teams */
  environmentId?: number;
}

export type TeamListData = PortainereeTeam[];

export type TeamCreateData = PortainereeTeam;

export type TeamDeleteData = any;

export type TeamInspectData = PortainereeTeam;

export type TeamUpdateData = PortainereeTeam;

export type TeamMembershipsData = PortainereeTeamMembership[];

export type TemplateListData = TemplatesListResponse;

export type TemplateFileData = TemplatesFileResponse;

export interface HelmRepoSearchParams {
  /** Helm repository URL */
  repo: string;
}

export type HelmRepoSearchData = string;

export interface HelmShowParams {
  /** Helm repository URL */
  repo: string;
  /** Chart name */
  chart: string;
  /** chart/values/readme */
  command: string;
}

export type HelmShowData = string;

export interface UploadTlsPayload {
  /** Folder where the TLS file will be stored. Will be created if not existing */
  folder: string;
  /** The file to upload */
  file: File;
}

export type UploadTlsData = any;

export interface AuthLogsListParams {
  /** Pagination offset */
  offset?: number;
  /** Limit results */
  limit?: number;
  /** Results before timestamp (unix) */
  before?: number;
  /** Results after timestamp (unix) */
  after?: number;
  /** Sort by this column */
  sortBy?: string;
  /** Sort order, if true will return results by descending order */
  sortDesc?: boolean;
  /** Query logs by this keyword */
  keyword?: string;
}

export type AuthLogsListData = PortainereeAuthActivityLog[];

export interface AuthLogsCsvParams {
  /** Results before timestamp (unix) */
  before?: number;
  /** Results after timestamp (unix) */
  after?: number;
  /** Sort by this column */
  sortBy?: string;
  /** Sort order, if true will return results by descending order */
  sortDesc?: boolean;
  /** Limit results */
  limit?: number;
  /** Query logs by this keyword */
  keyword?: string;
}

export type AuthLogsCsvData = any;

export interface LogsListParams {
  /** Pagination offset */
  offset?: number;
  /** Limit results */
  limit?: number;
  /** Results before timestamp (unix) */
  before?: number;
  /** Results after timestamp (unix) */
  after?: number;
  /** Sort by this column */
  sortBy?: string;
  /** Sort order, if true will return results by descending order */
  sortDesc?: boolean;
  /** Query logs by this keyword */
  keyword?: string;
}

export type LogsListData = UseractivityLogsListResponse;

export interface LogsCsvParams {
  /** Results before timestamp (unix) */
  before?: number;
  /** Results after timestamp (unix) */
  after?: number;
  /** Sort by this column */
  sortBy?: string;
  /** Sort order, if true will return results by descending order */
  sortDesc?: boolean;
  /** Limit results */
  limit?: number;
  /** Query logs by this keyword */
  keyword?: string;
}

export type LogsCsvData = any;

export interface UserListParams {
  /** Identifier of the environment(endpoint) that will be used to filter the authorized users */
  environmentId?: number;
}

export type UserListData = PortainereeUser[];

export type UserCreateData = PortainereeUser;

export type UserDeleteData = any;

export type UserInspectData = PortainereeUser;

export type UserUpdateData = PortainereeUser;

export type UserGetGitCredentialsData = PortainereeGitCredential[];

export type UserCreateGitCredentialData = UsersGitCredentialResponse;

export type UserRemoveGitCredentialData = any;

export type UserGetGitCredentialData = PortainereeGitCredential;

export type UserUpdateGitCredentialData = any;

export type UserMembershipsInspectData = PortainereeTeamMembership;

export type UserNamespacesData = UsersNamespaceMapping;

export type UserUpdateOpenAiConfigData = any;

export type UserUpdatePasswordData = any;

export type UserGetApiKeysData = PortainereeAPIKey[];

export type UserGenerateApiKeyData = UsersAccessTokenResponse;

export type UserRemoveApiKeyData = any;

export type UserAdminCheckData = any;

export type UserAdminInitData = PortainereeUser;

export interface WebhooksListParams {
  EndpointID?: number;
  ResourceID?: string;
}

export type WebhooksListData = PortainereeWebhook[];

export type WebhooksCreateData = PortainereeWebhook;

export type WebhooksDeleteData = any;

export type WebhooksUpdateData = PortainereeWebhook;

export type ReassignUpdateData = PortainereeWebhook;

export type WebhooksCreate2Data = any;

export interface AttachListParams {
  /** environment(endpoint) ID of the environment(endpoint) where the resource is located */
  endpointId: number;
  /** node name */
  nodeName?: string;
  /** JWT token used for authentication against this environment(endpoint) */
  token: string;
}

export type AttachListData = any;

export interface ExecListParams {
  /** environment(endpoint) ID of the environment(endpoint) where the resource is located */
  endpointId: number;
  /** node name */
  nodeName?: string;
  /** JWT token used for authentication against this environment(endpoint) */
  token: string;
}

export type ExecListData = any;

export interface KubernetesShellListParams {
  /** environment(endpoint) ID of the environment(endpoint) where the resource is located */
  endpointId: number;
  /** JWT token used for authentication against this environment(endpoint) */
  token: string;
}

export type KubernetesShellListData = any;

export interface GetWebsocketParams {
  /** environment(endpoint) ID of the environment(endpoint) where the resource is located */
  endpointId: number;
  /** namespace where the container is located */
  namespace: string;
  /** name of the pod containing the container */
  podName: string;
  /** name of the container */
  containerName: string;
  /** command to execute in the container */
  command: string;
  /** JWT token used for authentication against this environment(endpoint) */
  token: string;
}

export type GetWebsocketData = any;

import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from "axios";
import axios from "axios";

export type QueryParamsType = Record<string | number, any>;

export interface FullRequestParams extends Omit<AxiosRequestConfig, "data" | "params" | "url" | "responseType"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseType;
  /** request body */
  body?: unknown;
}

export type RequestParams = Omit<FullRequestParams, "body" | "method" | "query" | "path">;

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, "data" | "cancelToken"> {
  securityWorker?: (
    securityData: SecurityDataType | null,
  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void;
  secure?: boolean;
  format?: ResponseType;
}

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public instance: AxiosInstance;
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private secure?: boolean;
  private format?: ResponseType;

  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
    this.instance = axios.create({ ...axiosConfig, baseURL: axiosConfig.baseURL || "/api" });
    this.secure = secure;
    this.format = format;
    this.securityWorker = securityWorker;
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
    const method = params1.method || (params2 && params2.method);

    return {
      ...this.instance.defaults,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected stringifyFormItem(formItem: unknown) {
    if (typeof formItem === "object" && formItem !== null) {
      return JSON.stringify(formItem);
    } else {
      return `${formItem}`;
    }
  }

  protected createFormData(input: Record<string, unknown>): FormData {
    return Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key];
      const propertyContent: any[] = property instanceof Array ? property : [property];

      for (const formItem of propertyContent) {
        const isFileType = formItem instanceof Blob || formItem instanceof File;
        formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem));
      }

      return formData;
    }, new FormData());
  }

  public request = async <T = any, _E = any>({
    secure,
    path,
    type,
    query,
    format,
    body,
    ...params
  }: FullRequestParams): Promise<AxiosResponse<T>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const responseFormat = format || this.format || undefined;

    if (type === ContentType.FormData && body && body !== null && typeof body === "object") {
      body = this.createFormData(body as Record<string, unknown>);
    }

    if (type === ContentType.Text && body && body !== null && typeof body !== "string") {
      body = JSON.stringify(body);
    }

    return this.instance.request({
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type && type !== ContentType.FormData ? { "Content-Type": type } : {}),
      },
      params: query,
      responseType: responseFormat,
      data: body,
      url: path,
    });
  };
}

/**
 * @title PortainerEE API
 * @version 2.18.4
 * @baseUrl /api
 * @contact <info@portainer.io>
 *
 * Portainer API is an HTTP API served by Portainer. It is used by the Portainer UI and everything you can do with the UI can be done using the HTTP API.
 * Examples are available at https://documentation.portainer.io/api/api-examples/
 * You can find out more about Portainer at [http://portainer.io](http://portainer.io) and get some support on [Slack](http://portainer.io/slack/).
 *
 * # Authentication
 *
 * Most of the API environments(endpoints) require to be authenticated as well as some level of authorization to be used.
 * Portainer API uses JSON Web Token to manage authentication and thus requires you to provide a token in the **Authorization** header of each request
 * with the **Bearer** authentication mechanism.
 *
 * Example:
 *
 * ```
 * Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJhZG1pbiIsInJvbGUiOjEsImV4cCI6MTQ5OTM3NjE1NH0.NJ6vE8FY1WG6jsRQzfMqeatJ4vh2TWAeeYfDhP71YEE
 * ```
 *
 * # Security
 *
 * Each API environment(endpoint) has an associated access policy, it is documented in the description of each environment(endpoint).
 *
 * Different access policies are available:
 *
 * - Public access
 * - Authenticated access
 * - Restricted access
 * - Administrator access
 *
 * ### Public access
 *
 * No authentication is required to access the environments(endpoints) with this access policy.
 *
 * ### Authenticated access
 *
 * Authentication is required to access the environments(endpoints) with this access policy.
 *
 * ### Restricted access
 *
 * Authentication is required to access the environments(endpoints) with this access policy.
 * Extra-checks might be added to ensure access to the resource is granted. Returned data might also be filtered.
 *
 * ### Administrator access
 *
 * Authentication as well as an administrator role are required to access the environments(endpoints) with this access policy.
 *
 * # Execute Docker requests
 *
 * Portainer **DO NOT** expose specific environments(endpoints) to manage your Docker resources (create a container, remove a volume, etc...).
 *
 * Instead, it acts as a reverse-proxy to the Docker HTTP API. This means that you can execute Docker requests **via** the Portainer HTTP API.
 *
 * To do so, you can use the `/endpoints/{id}/docker` Portainer API environment(endpoint) (which is not documented below due to Swagger limitations). This environment(endpoint) has a restricted access policy so you still need to be authenticated to be able to query this environment(endpoint). Any query on this environment(endpoint) will be proxied to the Docker API of the associated environment(endpoint) (requests and responses objects are the same as documented in the Docker API).
 *
 * # Private Registry
 *
 * Using private registry, you will need to pass a based64 encoded JSON string {"registryId":\<registryID value\>} inside the Request Header. The parameter name is "X-Registry-Auth".
 * \<registryID value\> - The registry ID where the repository was created.
 *
 * Example:
 *
 * ```
 * eyJyZWdpc3RyeUlkIjoxfQ==
 * ```
 *
 * **NOTE**: You can find more information on how to query the Docker API in the [Docker official documentation](https://docs.docker.com/engine/api/v1.30/) as well as in [this Portainer example](https://documentation.portainer.io/api/api-examples/).
 */
export class PortainerApi<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  auth = {
    /**
     * @description **Access policy**: public Use this environment(endpoint) to authenticate against Portainer using a username and password.
     *
     * @tags auth
     * @name AuthenticateUser
     * @summary Authenticate
     * @request POST:/auth
     */
    authenticateUser: (body: AuthAuthenticatePayload, params: RequestParams = {}) =>
      this.request<AuthenticateUserData, void>({
        path: `/auth`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags auth
     * @name Logout
     * @summary Logout
     * @request POST:/auth/logout
     * @secure
     */
    logout: (params: RequestParams = {}) =>
      this.request<LogoutData, void>({
        path: `/auth/logout`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: public
     *
     * @tags auth
     * @name ValidateOAuth
     * @summary Authenticate with OAuth
     * @request POST:/auth/oauth/validate
     */
    validateOAuth: (body: AuthOauthPayload, params: RequestParams = {}) =>
      this.request<ValidateOAuthData, void>({
        path: `/auth/oauth/validate`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),
  };
  backup = {
    /**
     * @description Creates an archive with a system data snapshot that could be used to restore the system. **Access policy**: admin
     *
     * @tags backup
     * @name Backup
     * @summary Creates an archive with a system data snapshot that could be used to restore the system.
     * @request POST:/backup
     * @secure
     */
    backup: (body: BackupBackupPayload, params: RequestParams = {}) =>
      this.request<BackupData, void>({
        path: `/backup`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Creates an archive with a system data snapshot and upload it to the target S3 bucket **Access policy**: administrator
     *
     * @tags backup
     * @name BackupToS3
     * @summary Execute backup to AWS S3 Bucket
     * @request POST:/backup/s3/execute
     * @secure
     */
    backupToS3: (body: BackupS3BackupPayload, params: RequestParams = {}) =>
      this.request<BackupToS3Data, void>({
        path: `/backup/s3/execute`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Triggers a system restore using details of s3 backup **Access policy**: public
     *
     * @tags backup
     * @name RestoreFromS3
     * @summary Triggers a system restore using details of s3 backup
     * @request POST:/backup/s3/restore
     */
    restoreFromS3: (body: BackupRestoreS3Settings, params: RequestParams = {}) =>
      this.request<RestoreFromS3Data, void>({
        path: `/backup/s3/restore`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags backup
     * @name BackupSettingsFetch
     * @summary Fetch s3 backup settings/configurations
     * @request GET:/backup/s3/settings
     * @secure
     */
    backupSettingsFetch: (params: RequestParams = {}) =>
      this.request<BackupSettingsFetchData, void>({
        path: `/backup/s3/settings`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Updates stored s3 backup settings and updates running cron jobs as needed **Access policy**: administrator
     *
     * @tags backup
     * @name UpdateS3Settings
     * @summary Updates stored s3 backup settings and updates running cron jobs as needed
     * @request POST:/backup/s3/settings
     * @secure
     */
    updateS3Settings: (s3_backup_settings: PortainereeS3BackupSettings, params: RequestParams = {}) =>
      this.request<UpdateS3SettingsData, void>({
        path: `/backup/s3/settings`,
        method: "POST",
        body: s3_backup_settings,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: public
     *
     * @tags backup
     * @name BackupStatusFetch
     * @summary Fetch the status of the last scheduled backup run
     * @request GET:/backup/s3/status
     */
    backupStatusFetch: (params: RequestParams = {}) =>
      this.request<BackupStatusFetchData, void>({
        path: `/backup/s3/status`,
        method: "GET",
        ...params,
      }),
  };
  chat = {
    /**
     * @description Send a chat query to the OpenAI API. **Access policy**: user
     *
     * @tags chat
     * @name ChatQuery
     * @summary Send a chat query to the OpenAI API
     * @request POST:/chat
     * @secure
     */
    chatQuery: (body: ChatChatQueryPayload, params: RequestParams = {}) =>
      this.request<ChatQueryData, void>({
        path: `/chat`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  cloud = {
    /**
     * @description Provision a new KaaS cluster and create an environment. **Access policy**: administrator
     *
     * @tags kaas
     * @name ProvisionKaaSCluster
     * @summary Provision a new KaaS cluster and create an environment
     * @request POST:/cloud/{provider}
     * @secure
     */
    provisionKaaSCluster: (provider: number, body_api: ProvidersAzureProvisionPayload, params: RequestParams = {}) =>
      this.request<ProvisionKaaSClusterData, void>({
        path: `/cloud/${provider}`,
        method: "POST",
        body: body_api,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description The information returned can be used to provision a KaaS cluster. **Access policy**: administrator
     *
     * @tags kaas
     * @name KaasProviderInfo
     * @summary Get information about the provisioning options for a cloud provider.
     * @request GET:/cloud/{provider}/info
     * @secure
     */
    kaasProviderInfo: ({ provider, ...query }: KaasProviderInfoParams, params: RequestParams = {}) =>
      this.request<KaasProviderInfoData, void>({
        path: `/cloud/${provider}/info`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description The information returned can be used to query the MircoK8s cluster. **Access policy**: authenticated
     *
     * @tags kaas
     * @name Microk8SAddons
     * @summary Get a list of addons which are installed in a MicroK8s cluster.
     * @request GET:/cloud/microk8s/addons
     * @secure
     */
    microk8SAddons: (query: Microk8SAddonsParams, params: RequestParams = {}) =>
      this.request<Microk8SAddonsData, void>({
        path: `/cloud/microk8s/addons`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
  cloudcredentials = {
    /**
     * @description getByID gets a cloud credential by ID **Access policy**: authenticated
     *
     * @tags cloud_credentials
     * @name GetById
     * @summary getByID gets a cloud credential by ID
     * @request GET:/cloudcredentials
     * @secure
     */
    getById: (query: GetByIdParams, params: RequestParams = {}) =>
      this.request<GetByIdData, void>({
        path: `/cloudcredentials`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description delete delete a cloud credential by ID **Access policy**: authenticated
     *
     * @tags cloud_credentials
     * @name Delete
     * @summary delete delete a cloud credential by ID
     * @request POST:/cloudcredentials
     * @secure
     */
    delete: (query: DeleteParams, params: RequestParams = {}) =>
      this.request<DeleteData, void>({
        path: `/cloudcredentials`,
        method: "POST",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Update a cloud credential **Access policy**: authenticated
     *
     * @tags cloud_credentials
     * @name Update
     * @summary Update a cloud credential
     * @request PUT:/cloudcredentials
     * @secure
     */
    update: (data: UpdatePayload, params: RequestParams = {}) =>
      this.request<UpdateData, void>({
        path: `/cloudcredentials`,
        method: "PUT",
        body: data,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  customTemplates = {
    /**
     * @description List available custom templates. **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateList
     * @summary List available custom templates
     * @request GET:/custom_templates
     * @secure
     */
    customTemplateList: (query: CustomTemplateListParams, params: RequestParams = {}) =>
      this.request<CustomTemplateListData, void>({
        path: `/custom_templates`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Create a custom template. **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateCreate
     * @summary Create a custom template
     * @request POST:/custom_templates
     * @secure
     */
    customTemplateCreate: (
      query: CustomTemplateCreateParams,
      body_repository: CustomTemplateCreatePayload,
      params: RequestParams = {},
    ) =>
      this.request<CustomTemplateCreateData, void>({
        path: `/custom_templates`,
        method: "POST",
        query: query,
        body: body_repository,
        secure: true,
        type: ContentType.FormData,
        ...params,
      }),

    /**
     * @description Remove a template. **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateDelete
     * @summary Remove a template
     * @request DELETE:/custom_templates/{id}
     * @secure
     */
    customTemplateDelete: (id: number, params: RequestParams = {}) =>
      this.request<CustomTemplateDeleteData, void>({
        path: `/custom_templates/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about a template. **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateInspect
     * @summary Inspect a custom template
     * @request GET:/custom_templates/{id}
     * @secure
     */
    customTemplateInspect: (id: number, params: RequestParams = {}) =>
      this.request<CustomTemplateInspectData, void>({
        path: `/custom_templates/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a template. **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateUpdate
     * @summary Update a template
     * @request PUT:/custom_templates/{id}
     * @secure
     */
    customTemplateUpdate: (id: number, body: CustomtemplatesCustomTemplateUpdatePayload, params: RequestParams = {}) =>
      this.request<CustomTemplateUpdateData, void>({
        path: `/custom_templates/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Retrieve the content of the Stack file for the specified custom template **Access policy**: authenticated
     *
     * @tags custom_templates
     * @name CustomTemplateFile
     * @summary Get Template stack file content.
     * @request GET:/custom_templates/{id}/file
     * @secure
     */
    customTemplateFile: (id: number, params: RequestParams = {}) =>
      this.request<CustomTemplateFileData, void>({
        path: `/custom_templates/${id}/file`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  docker = {
    /**
     * @description **Access policy**:
     *
     * @tags docker
     * @name ContainerImageStatus
     * @summary Fetch image status for container
     * @request GET:/docker/{environmentId}/containers/{containerID}/image_status
     * @secure
     */
    containerImageStatus: (environmentId: string, containerId: string, params: RequestParams = {}) =>
      this.request<ContainerImageStatusData, void>({
        path: `/docker/${environmentId}/containers/${containerId}/image_status`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags docker
     * @name DockerContainerGpusInspect
     * @summary Fetch container gpus data
     * @request GET:/docker/{environmentId}/containers/{containerId}/gpus
     * @secure
     */
    dockerContainerGpusInspect: (environmentId: number, containerId: number, params: RequestParams = {}) =>
      this.request<DockerContainerGpusInspectData, void>({
        path: `/docker/${environmentId}/containers/${containerId}/gpus`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags docker
     * @name ServiceImageStatus
     * @summary Fetch image status for service
     * @request GET:/docker/{environmentId}/services/{serviceID}/image_status
     * @secure
     */
    serviceImageStatus: (environmentId: string, serviceId: string, params: RequestParams = {}) =>
      this.request<ServiceImageStatusData, void>({
        path: `/docker/${environmentId}/services/${serviceId}/image_status`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags endpoints, docker
     * @name SnapshotInspect
     * @summary Fetch latest snapshot of environment
     * @request GET:/docker/{environmentId}/snapshot
     * @secure
     */
    snapshotInspect: (environmentId: number, params: RequestParams = {}) =>
      this.request<SnapshotInspectData, void>({
        path: `/docker/${environmentId}/snapshot`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags endpoints, docker
     * @name SnapshotContainersList
     * @summary Fetch containers list from a snapshot
     * @request GET:/docker/{environmentId}/snapshot/containers
     * @secure
     */
    snapshotContainersList: ({ environmentId, ...query }: SnapshotContainersListParams, params: RequestParams = {}) =>
      this.request<SnapshotContainersListData, void>({
        path: `/docker/${environmentId}/snapshot/containers`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags endpoints, docker
     * @name SnapshotContainerInspect
     * @summary Fetch container from a snapshot
     * @request GET:/docker/{environmentId}/snapshot/containers/{containerId}
     * @secure
     */
    snapshotContainerInspect: (environmentId: number, containerId: string, params: RequestParams = {}) =>
      this.request<SnapshotContainerInspectData, void>({
        path: `/docker/${environmentId}/snapshot/containers/${containerId}`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**:
     *
     * @tags docker
     * @name StackImagesStatus
     * @summary Fetch image status for stack
     * @request GET:/docker/{environmentId}/stacks/{id}/images_status
     * @secure
     */
    stackImagesStatus: (environmentId: string, id: string, params: RequestParams = {}) =>
      this.request<StackImagesStatusData, void>({
        path: `/docker/${environmentId}/stacks/${id}/images_status`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  edgeGroups = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_groups
     * @name EdgeGroupList
     * @summary list EdgeGroups
     * @request GET:/edge_groups
     * @secure
     */
    edgeGroupList: (params: RequestParams = {}) =>
      this.request<EdgeGroupListData, void>({
        path: `/edge_groups`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_groups
     * @name EdgeGroupCreate
     * @summary Create an EdgeGroup
     * @request POST:/edge_groups
     * @secure
     */
    edgeGroupCreate: (body: EdgegroupsEdgeGroupCreatePayload, params: RequestParams = {}) =>
      this.request<EdgeGroupCreateData, void>({
        path: `/edge_groups`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_groups
     * @name EdgeGroupDelete
     * @summary Deletes an EdgeGroup
     * @request DELETE:/edge_groups/{id}
     * @secure
     */
    edgeGroupDelete: (id: number, params: RequestParams = {}) =>
      this.request<EdgeGroupDeleteData, void>({
        path: `/edge_groups/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_groups
     * @name EdgeGroupInspect
     * @summary Inspects an EdgeGroup
     * @request GET:/edge_groups/{id}
     * @secure
     */
    edgeGroupInspect: (id: number, params: RequestParams = {}) =>
      this.request<EdgeGroupInspectData, void>({
        path: `/edge_groups/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_groups
     * @name EgeGroupUpdate
     * @summary Updates an EdgeGroup
     * @request PUT:/edge_groups/{id}
     * @secure
     */
    egeGroupUpdate: (id: number, body: EdgegroupsEdgeGroupUpdatePayload, params: RequestParams = {}) =>
      this.request<EgeGroupUpdateData, void>({
        path: `/edge_groups/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  edgeJobs = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobList
     * @summary Fetch EdgeJobs list
     * @request GET:/edge_jobs
     * @secure
     */
    edgeJobList: (params: RequestParams = {}) =>
      this.request<EdgeJobListData, void>({
        path: `/edge_jobs`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobCreate
     * @summary Create an EdgeJob
     * @request POST:/edge_jobs
     * @secure
     */
    edgeJobCreate: (
      query: EdgeJobCreateParams,
      body_file: EdgejobsEdgeJobCreateFromFileContentPayload,
      params: RequestParams = {},
    ) =>
      this.request<EdgeJobCreateData, void>({
        path: `/edge_jobs`,
        method: "POST",
        query: query,
        body: body_file,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobDelete
     * @summary Delete an EdgeJob
     * @request DELETE:/edge_jobs/{id}
     * @secure
     */
    edgeJobDelete: (id: number, params: RequestParams = {}) =>
      this.request<EdgeJobDeleteData, void>({
        path: `/edge_jobs/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobInspect
     * @summary Inspect an EdgeJob
     * @request GET:/edge_jobs/{id}
     * @secure
     */
    edgeJobInspect: (id: number, params: RequestParams = {}) =>
      this.request<EdgeJobInspectData, void>({
        path: `/edge_jobs/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobUpdate
     * @summary Update an EdgeJob
     * @request POST:/edge_jobs/{id}
     * @secure
     */
    edgeJobUpdate: (id: number, body: EdgejobsEdgeJobUpdatePayload, params: RequestParams = {}) =>
      this.request<EdgeJobUpdateData, void>({
        path: `/edge_jobs/${id}`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobFile
     * @summary Fetch a file of an EdgeJob
     * @request GET:/edge_jobs/{id}/file
     * @secure
     */
    edgeJobFile: (id: number, params: RequestParams = {}) =>
      this.request<EdgeJobFileData, void>({
        path: `/edge_jobs/${id}/file`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobTasksList
     * @summary Fetch the list of tasks on an EdgeJob
     * @request GET:/edge_jobs/{id}/tasks
     * @secure
     */
    edgeJobTasksList: (id: number, params: RequestParams = {}) =>
      this.request<EdgeJobTasksListData, void>({
        path: `/edge_jobs/${id}/tasks`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobTasksClear
     * @summary Clear the log for a specifc task on an EdgeJob
     * @request DELETE:/edge_jobs/{id}/tasks/{taskID}/logs
     * @secure
     */
    edgeJobTasksClear: (id: number, taskId: number, params: RequestParams = {}) =>
      this.request<EdgeJobTasksClearData, void>({
        path: `/edge_jobs/${id}/tasks/${taskId}/logs`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobTaskLogsInspect
     * @summary Fetch the log for a specifc task on an EdgeJob
     * @request GET:/edge_jobs/{id}/tasks/{taskID}/logs
     * @secure
     */
    edgeJobTaskLogsInspect: (id: number, taskId: number, params: RequestParams = {}) =>
      this.request<EdgeJobTaskLogsInspectData, void>({
        path: `/edge_jobs/${id}/tasks/${taskId}/logs`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_jobs
     * @name EdgeJobTasksCollect
     * @summary Collect the log for a specifc task on an EdgeJob
     * @request POST:/edge_jobs/{id}/tasks/{taskID}/logs
     * @secure
     */
    edgeJobTasksCollect: (id: number, taskId: number, params: RequestParams = {}) =>
      this.request<EdgeJobTasksCollectData, void>({
        path: `/edge_jobs/${id}/tasks/${taskId}/logs`,
        method: "POST",
        secure: true,
        ...params,
      }),
  };
  edgeStacks = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackList
     * @summary Fetches the list of EdgeStacks
     * @request GET:/edge_stacks
     * @secure
     */
    edgeStackList: (params: RequestParams = {}) =>
      this.request<EdgeStackListData, void>({
        path: `/edge_stacks`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackCreate
     * @summary Create an EdgeStack
     * @request POST:/edge_stacks
     * @secure
     */
    edgeStackCreate: (
      query: EdgeStackCreateParams,
      body_repository: EdgestacksSwarmStackFromFileContentPayload,
      params: RequestParams = {},
    ) =>
      this.request<EdgeStackCreateData, void>({
        path: `/edge_stacks`,
        method: "POST",
        query: query,
        body: body_repository,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackDelete
     * @summary Delete an EdgeStack
     * @request DELETE:/edge_stacks/{id}
     * @secure
     */
    edgeStackDelete: (id: number, params: RequestParams = {}) =>
      this.request<EdgeStackDeleteData, void>({
        path: `/edge_stacks/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackInspect
     * @summary Inspect an EdgeStack
     * @request GET:/edge_stacks/{id}
     * @secure
     */
    edgeStackInspect: (id: number, params: RequestParams = {}) =>
      this.request<EdgeStackInspectData, void>({
        path: `/edge_stacks/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackUpdate
     * @summary Update an EdgeStack
     * @request PUT:/edge_stacks/{id}
     * @secure
     */
    edgeStackUpdate: (id: number, body: EdgestacksUpdateEdgeStackPayload, params: RequestParams = {}) =>
      this.request<EdgeStackUpdateData, void>({
        path: `/edge_stacks/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackFile
     * @summary Fetches the stack file for an EdgeStack
     * @request GET:/edge_stacks/{id}/file
     * @secure
     */
    edgeStackFile: (id: number, params: RequestParams = {}) =>
      this.request<EdgeStackFileData, void>({
        path: `/edge_stacks/${id}/file`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackLogsDelete
     * @summary Deletes the available logs for a given edge stack and endpoint
     * @request DELETE:/edge_stacks/{id}/logs/{endpoint_id}
     * @secure
     */
    edgeStackLogsDelete: (id: number, endpointId: number, params: RequestParams = {}) =>
      this.request<EdgeStackLogsDeleteData, void>({
        path: `/edge_stacks/${id}/logs/${endpointId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackLogsStatusGet
     * @summary Gets the status of the log collection for a given edgestack and environment
     * @request GET:/edge_stacks/{id}/logs/{endpoint_id}
     * @secure
     */
    edgeStackLogsStatusGet: (id: number, endpointId: number, params: RequestParams = {}) =>
      this.request<EdgeStackLogsStatusGetData, void>({
        path: `/edge_stacks/${id}/logs/${endpointId}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_stacks
     * @name EdgeStackLogsCollect
     * @summary Schedule the collection of logs for a given endpoint and edge stack
     * @request PUT:/edge_stacks/{id}/logs/{endpoint_id}
     * @secure
     */
    edgeStackLogsCollect: ({ id, endpointId, ...query }: EdgeStackLogsCollectParams, params: RequestParams = {}) =>
      this.request<EdgeStackLogsCollectData, void>({
        path: `/edge_stacks/${id}/logs/${endpointId}`,
        method: "PUT",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Authorized only if the request is done by an Edge Environment(Endpoint)
     *
     * @tags edge_stacks
     * @name EdgeStackStatusUpdate
     * @summary Update an EdgeStack status
     * @request PUT:/edge_stacks/{id}/status
     */
    edgeStackStatusUpdate: (id: number, params: RequestParams = {}) =>
      this.request<EdgeStackStatusUpdateData, void>({
        path: `/edge_stacks/${id}/status`,
        method: "PUT",
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Authorized only if the request is done by an Edge Environment(Endpoint)
     *
     * @tags edge_stacks
     * @name EdgeStackStatusDelete
     * @summary Delete an EdgeStack status
     * @request DELETE:/edge_stacks/{id}/status/{endpoint_id}
     */
    edgeStackStatusDelete: (id: number, endpointId: string, params: RequestParams = {}) =>
      this.request<EdgeStackStatusDeleteData, void>({
        path: `/edge_stacks/${id}/status/${endpointId}`,
        method: "DELETE",
        ...params,
      }),
  };
  edgeTemplates = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_templates
     * @name EdgeTemplateList
     * @summary Fetches the list of Edge Templates
     * @request GET:/edge_templates
     * @secure
     */
    edgeTemplateList: (params: RequestParams = {}) =>
      this.request<EdgeTemplateListData, void>({
        path: `/edge_templates`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  edgeUpdateSchedules = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdateScheduleList
     * @summary Fetches the list of Edge Update Schedules
     * @request GET:/edge_update_schedules
     * @secure
     */
    edgeUpdateScheduleList: (params: RequestParams = {}) =>
      this.request<EdgeUpdateScheduleListData, void>({
        path: `/edge_update_schedules`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdateScheduleUpdate
     * @summary Updates an Edge Update Schedule
     * @request POST:/edge_update_schedules
     * @secure
     */
    edgeUpdateScheduleUpdate: (body: EdgeupdateschedulesUpdatePayload, params: RequestParams = {}) =>
      this.request<EdgeUpdateScheduleUpdateData, void>({
        path: `/edge_update_schedules`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdateScheduleDelete
     * @summary Deletes an Edge Update Schedule
     * @request DELETE:/edge_update_schedules/{id}
     * @secure
     */
    edgeUpdateScheduleDelete: (id: string, params: RequestParams = {}) =>
      this.request<EdgeUpdateScheduleDeleteData, void>({
        path: `/edge_update_schedules/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdateScheduleInspect
     * @summary Returns the Edge Update Schedule with the given ID
     * @request GET:/edge_update_schedules/{id}
     * @secure
     */
    edgeUpdateScheduleInspect: (id: string, params: RequestParams = {}) =>
      this.request<EdgeUpdateScheduleInspectData, void>({
        path: `/edge_update_schedules/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdateScheduleActiveSchedulesList
     * @summary Fetches the list of Active Edge Update Schedules
     * @request GET:/edge_update_schedules/active
     * @secure
     */
    edgeUpdateScheduleActiveSchedulesList: (
      body: EdgeupdateschedulesActiveSchedulePayload,
      params: RequestParams = {},
    ) =>
      this.request<EdgeUpdateScheduleActiveSchedulesListData, void>({
        path: `/edge_update_schedules/active`,
        method: "GET",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags edge_update_schedules
     * @name AgentVersions
     * @summary Fetches the supported versions of the agent to update/rollback
     * @request GET:/edge_update_schedules/agent_versions
     * @secure
     */
    agentVersions: (params: RequestParams = {}) =>
      this.request<AgentVersionsData, void>({
        path: `/edge_update_schedules/agent_versions`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags edge_update_schedules
     * @name EdgeUpdatePreviousVersions
     * @summary Fetches the previous versions of updated agents
     * @request GET:/edge_update_schedules/previous_versions
     * @secure
     */
    edgeUpdatePreviousVersions: (params: RequestParams = {}) =>
      this.request<EdgeUpdatePreviousVersionsData, void>({
        path: `/edge_update_schedules/previous_versions`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  endpointGroups = {
    /**
     * @description List all environment(endpoint) groups based on the current user authorizations. Will return all environment(endpoint) groups if using an administrator account otherwise it will only return authorized environment(endpoint) groups. **Access policy**: restricted
     *
     * @tags endpoint_groups
     * @name EndpointGroupList
     * @summary List Environment(Endpoint) groups
     * @request GET:/endpoint_groups
     * @secure
     */
    endpointGroupList: (params: RequestParams = {}) =>
      this.request<EndpointGroupListData, void>({
        path: `/endpoint_groups`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new environment(endpoint) group. **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupsCreate
     * @summary Create an Environment(Endpoint) Group
     * @request POST:/endpoint_groups
     * @secure
     */
    endpointGroupsCreate: (body: EndpointgroupsEndpointGroupCreatePayload, params: RequestParams = {}) =>
      this.request<EndpointGroupsCreateData, void>({
        path: `/endpoint_groups`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove an environment(endpoint) group. **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupDelete
     * @summary Remove an environment(endpoint) group
     * @request DELETE:/endpoint_groups/{id}
     * @secure
     */
    endpointGroupDelete: (id: number, params: RequestParams = {}) =>
      this.request<EndpointGroupDeleteData, void>({
        path: `/endpoint_groups/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details abont an environment(endpoint) group. **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupsDetail
     * @summary Inspect an Environment(Endpoint) group
     * @request GET:/endpoint_groups/{id}
     * @secure
     */
    endpointGroupsDetail: (id: number, params: RequestParams = {}) =>
      this.request<EndpointGroupsDetailData, void>({
        path: `/endpoint_groups/${id}`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Update an environment(endpoint) group. **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupUpdate
     * @summary Update an environment(endpoint) group
     * @request PUT:/endpoint_groups/{id}
     * @secure
     */
    endpointGroupUpdate: (id: number, body: EndpointgroupsEndpointGroupUpdatePayload, params: RequestParams = {}) =>
      this.request<EndpointGroupUpdateData, void>({
        path: `/endpoint_groups/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupDeleteEndpoint
     * @summary Removes environment(endpoint) from an environment(endpoint) group
     * @request DELETE:/endpoint_groups/{id}/endpoints/{endpointId}
     * @secure
     */
    endpointGroupDeleteEndpoint: (id: number, endpointId: number, params: RequestParams = {}) =>
      this.request<EndpointGroupDeleteEndpointData, void>({
        path: `/endpoint_groups/${id}/endpoints/${endpointId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Add an environment(endpoint) to an environment(endpoint) group **Access policy**: administrator
     *
     * @tags endpoint_groups
     * @name EndpointGroupAddEndpoint
     * @summary Add an environment(endpoint) to an environment(endpoint) group
     * @request PUT:/endpoint_groups/{id}/endpoints/{endpointId}
     * @secure
     */
    endpointGroupAddEndpoint: (id: number, endpointId: number, params: RequestParams = {}) =>
      this.request<EndpointGroupAddEndpointData, void>({
        path: `/endpoint_groups/${id}/endpoints/${endpointId}`,
        method: "PUT",
        secure: true,
        ...params,
      }),
  };
  endpoints = {
    /**
     * @description List all environments(endpoints) based on the current user authorizations. Will return all environments(endpoints) if using an administrator or team leader account otherwise it will only return authorized environments(endpoints). **Access policy**: restricted
     *
     * @tags endpoints
     * @name EndpointList
     * @summary List environments(endpoints)
     * @request GET:/endpoints
     * @secure
     */
    endpointList: (query: EndpointListParams, params: RequestParams = {}) =>
      this.request<EndpointListData, void>({
        path: `/endpoints`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new environment(endpoint) that will be used to manage an environment(endpoint). **Access policy**: administrator
     *
     * @tags endpoints
     * @name EndpointCreate
     * @summary Create a new environment(endpoint)
     * @request POST:/endpoints
     * @secure
     */
    endpointCreate: (data: EndpointCreatePayload, params: RequestParams = {}) =>
      this.request<EndpointCreateData, void>({
        path: `/endpoints`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        ...params,
      }),

    /**
     * @description Remove an environment(endpoint). **Access policy**: administrator
     *
     * @tags endpoints
     * @name EndpointDelete
     * @summary Remove an environment(endpoint)
     * @request DELETE:/endpoints/{id}
     * @secure
     */
    endpointDelete: (id: number, params: RequestParams = {}) =>
      this.request<EndpointDeleteData, void>({
        path: `/endpoints/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about an environment(endpoint). **Access policy**: restricted
     *
     * @tags endpoints
     * @name EndpointInspect
     * @summary Inspect an environment(endpoint)
     * @request GET:/endpoints/{id}
     * @secure
     */
    endpointInspect: (id: number, params: RequestParams = {}) =>
      this.request<EndpointInspectData, void>({
        path: `/endpoints/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update an environment(endpoint). **Access policy**: authenticated
     *
     * @tags endpoints
     * @name EndpointUpdate
     * @summary Update an environment(endpoint)
     * @request PUT:/endpoints/{id}
     * @secure
     */
    endpointUpdate: (id: number, body: EndpointsEndpointUpdatePayload, params: RequestParams = {}) =>
      this.request<EndpointUpdateData, void>({
        path: `/endpoints/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description De-association an edge environment(endpoint). **Access policy**: administrator
     *
     * @tags endpoints
     * @name EndpointAssociationDelete
     * @summary De-association an edge environment(endpoint)
     * @request PUT:/endpoints/{id}/association
     * @secure
     */
    endpointAssociationDelete: (id: number, params: RequestParams = {}) =>
      this.request<EndpointAssociationDeleteData, void>({
        path: `/endpoints/${id}/association`,
        method: "PUT",
        secure: true,
        ...params,
      }),

    /**
     * @description Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     *
     * @tags endpoints
     * @name DockerV2BrowsePutCreate
     * @summary Upload a file under a specific path on the file system of an environment (endpoint)
     * @request POST:/endpoints/{id}/docker/v2/browse/put
     * @secure
     */
    dockerV2BrowsePutCreate: (
      { id, ...query }: DockerV2BrowsePutCreateParams,
      data: DockerV2BrowsePutCreatePayload,
      params: RequestParams = {},
    ) =>
      this.request<DockerV2BrowsePutCreateData, void>({
        path: `/endpoints/${id}/docker/v2/browse/put`,
        method: "POST",
        query: query,
        body: data,
        secure: true,
        type: ContentType.FormData,
        ...params,
      }),

    /**
     * @description get docker pull limits for a docker hub registry in the environment **Access policy**:
     *
     * @tags endpoints
     * @name EndpointDockerhubStatus
     * @summary fetch docker pull limits
     * @request GET:/endpoints/{id}/dockerhub/{registryId}
     * @secure
     */
    endpointDockerhubStatus: (id: number, registryId: number, params: RequestParams = {}) =>
      this.request<EndpointDockerhubStatusData, void>({
        path: `/endpoints/${id}/dockerhub/${registryId}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Generates a general edge key **Access policy**: admin
     *
     * @tags edge, endpoints
     * @name EdgeGenerateKeyDetail
     * @summary Generate an EdgeKey
     * @request GET:/endpoints/{id}/edge/generate-key
     */
    edgeGenerateKeyDetail: (id: string, body: EndpointedgeGenerateKeyResponse, params: RequestParams = {}) =>
      this.request<EdgeGenerateKeyDetailData, void>({
        path: `/endpoints/${id}/edge/generate-key`,
        method: "GET",
        body: body,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: public
     *
     * @tags edge, endpoints
     * @name EdgeJobsLogsCreate
     * @summary Inspect an EdgeJob Log
     * @request POST:/endpoints/{id}/edge/jobs/{jobID}/logs
     */
    edgeJobsLogsCreate: (id: number, jobId: number, params: RequestParams = {}) =>
      this.request<EdgeJobsLogsCreateData, void>({
        path: `/endpoints/${id}/edge/jobs/${jobId}/logs`,
        method: "POST",
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: public
     *
     * @tags edge, endpoints, edge_stacks
     * @name EdgeStacksDetail
     * @summary Inspect an Edge Stack for an Environment(Endpoint)
     * @request GET:/endpoints/{id}/edge/stacks/{stackId}
     */
    edgeStacksDetail: (id: number, stackId: number, params: RequestParams = {}) =>
      this.request<EdgeStacksDetailData, void>({
        path: `/endpoints/${id}/edge/stacks/${stackId}`,
        method: "GET",
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description environment(endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
     *
     * @tags endpoints
     * @name EndpointEdgeStatusInspect
     * @summary Get environment(endpoint) status
     * @request GET:/endpoints/{id}/edge/status
     * @secure
     */
    endpointEdgeStatusInspect: (id: number, params: RequestParams = {}) =>
      this.request<EndpointEdgeStatusInspectData, void>({
        path: `/endpoints/${id}/edge/status`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: admin
     *
     * @tags edge, endpoints
     * @name EdgeTrustCreate
     * @summary Trust an edge device
     * @request POST:/endpoints/{id}/edge/trust
     */
    edgeTrustCreate: (id: number, params: RequestParams = {}) =>
      this.request<EdgeTrustCreateData, void>({
        path: `/endpoints/${id}/edge/trust`,
        method: "POST",
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description force update a docker service **Access policy**: authenticated
     *
     * @tags endpoints
     * @name EndpointForceUpdateService
     * @summary force update a docker service
     * @request PUT:/endpoints/{id}/forceupdateservice
     * @secure
     */
    endpointForceUpdateService: (id: number, body: EndpointsForceUpdateServicePayload, params: RequestParams = {}) =>
      this.request<EndpointForceUpdateServiceData, void>({
        path: `/endpoints/${id}/forceupdateservice`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmList
     * @summary List Helm Releases
     * @request GET:/endpoints/{id}/kubernetes/helm
     * @secure
     */
    helmList: ({ id, ...query }: HelmListParams, params: RequestParams = {}) =>
      this.request<HelmListData, void>({
        path: `/endpoints/${id}/kubernetes/helm`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmInstall
     * @summary Install Helm Chart
     * @request POST:/endpoints/{id}/kubernetes/helm
     * @secure
     */
    helmInstall: (id: number, payload: HelmInstallChartPayload, params: RequestParams = {}) =>
      this.request<HelmInstallData, void>({
        path: `/endpoints/${id}/kubernetes/helm`,
        method: "POST",
        body: payload,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmDelete
     * @summary Delete Helm Release
     * @request DELETE:/endpoints/{id}/kubernetes/helm/{release}
     * @secure
     */
    helmDelete: ({ id, release, ...query }: HelmDeleteParams, params: RequestParams = {}) =>
      this.request<HelmDeleteData, void>({
        path: `/endpoints/${id}/kubernetes/helm/${release}`,
        method: "DELETE",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Inspect a user helm repositories. **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmUserRepositoriesList
     * @summary List a users helm repositories
     * @request GET:/endpoints/{id}/kubernetes/helm/repositories
     * @secure
     */
    helmUserRepositoriesList: (id: number, params: RequestParams = {}) =>
      this.request<HelmUserRepositoriesListData, void>({
        path: `/endpoints/${id}/kubernetes/helm/repositories`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a user helm repository. **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmUserRepositoryCreate
     * @summary Create a user helm repository
     * @request POST:/endpoints/{id}/kubernetes/helm/repositories
     * @secure
     */
    helmUserRepositoryCreate: (id: number, payload: HelmAddHelmRepoUrlPayload, params: RequestParams = {}) =>
      this.request<HelmUserRepositoryCreateData, void>({
        path: `/endpoints/${id}/kubernetes/helm/repositories`,
        method: "POST",
        body: payload,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description update the access on the resource pool in the current environment **Access policy**: restricted
     *
     * @tags endpoints
     * @name EndpointPoolsAccessUpdate
     * @summary update resource pool access
     * @request PUT:/endpoints/{id}/pools/{rpn}/access
     * @secure
     */
    endpointPoolsAccessUpdate: (
      id: number,
      rpn: number,
      body: EndpointsResourcePoolUpdatePayload,
      params: RequestParams = {},
    ) =>
      this.request<EndpointPoolsAccessUpdateData, void>({
        path: `/endpoints/${id}/pools/${rpn}/access`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List all registries based on the current user authorizations in current environment. **Access policy**: authenticated
     *
     * @tags endpoints
     * @name EndpointRegistriesList
     * @summary List Registries on environment
     * @request GET:/endpoints/{id}/registries
     * @secure
     */
    endpointRegistriesList: ({ id, ...query }: EndpointRegistriesListParams, params: RequestParams = {}) =>
      this.request<EndpointRegistriesListData, void>({
        path: `/endpoints/${id}/registries`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags endpoints
     * @name EndpointRegistryAccess
     * @summary update registry access for environment
     * @request PUT:/endpoints/{id}/registries/{registryId}
     * @secure
     */
    endpointRegistryAccess: (
      id: number,
      registryId: number,
      body: EndpointsRegistryAccessPayload,
      params: RequestParams = {},
    ) =>
      this.request<EndpointRegistryAccessData, void>({
        path: `/endpoints/${id}/registries/${registryId}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Update settings for an environment(endpoint). **Access policy**: authenticated
     *
     * @tags endpoints
     * @name EndpointSettingsUpdate
     * @summary Update settings for an environment(endpoint)
     * @request PUT:/endpoints/{id}/settings
     * @secure
     */
    endpointSettingsUpdate: (id: number, body: EndpointsEndpointSettingsUpdatePayload, params: RequestParams = {}) =>
      this.request<EndpointSettingsUpdateData, void>({
        path: `/endpoints/${id}/settings`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Snapshots an environment(endpoint) **Access policy**: administrator
     *
     * @tags endpoints
     * @name EndpointSnapshot
     * @summary Snapshots an environment(endpoint)
     * @request POST:/endpoints/{id}/snapshot
     * @secure
     */
    endpointSnapshot: (id: number, params: RequestParams = {}) =>
      this.request<EndpointSnapshotData, void>({
        path: `/endpoints/${id}/snapshot`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description Environment(Endpoint) for edge agent to check status of environment(endpoint) **Access policy**: restricted only to Edge environments(endpoints)
     *
     * @tags endpoints
     * @name EndpointEdgeAsync
     * @summary Get environment(endpoint) status
     * @request POST:/endpoints/edge/async
     * @secure
     */
    endpointEdgeAsync: (id: number, params: RequestParams = {}) =>
      this.request<EndpointEdgeAsyncData, void>({
        path: `/endpoints/edge/async`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * No description
     *
     * @tags endpoints
     * @name EndpointCreateGlobalKey
     * @summary Create or retrieve the endpoint for an EdgeID
     * @request POST:/endpoints/global-key
     */
    endpointCreateGlobalKey: (params: RequestParams = {}) =>
      this.request<EndpointCreateGlobalKeyData, void>({
        path: `/endpoints/global-key`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Snapshot all environments(endpoints) **Access policy**: administrator
     *
     * @tags endpoints
     * @name EndpointSnapshots
     * @summary Snapshot all environment(endpoint)
     * @request POST:/endpoints/snapshot
     * @secure
     */
    endpointSnapshots: (params: RequestParams = {}) =>
      this.request<EndpointSnapshotsData, void>({
        path: `/endpoints/snapshot`,
        method: "POST",
        secure: true,
        ...params,
      }),
  };
  fdo = {
    /**
     * @description Enable Portainer's FDO capabilities **Access policy**: administrator
     *
     * @tags intel
     * @name FdoConfigure
     * @summary Enable Portainer's FDO capabilities
     * @request POST:/fdo
     * @secure
     */
    fdoConfigure: (body: FdoFdoConfigurePayload, params: RequestParams = {}) =>
      this.request<FdoConfigureData, void>({
        path: `/fdo`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description configures an FDO device **Access policy**: administrator
     *
     * @tags intel
     * @name FdoConfigureDevice
     * @summary configures an FDO device
     * @request POST:/fdo/configure/{guid}
     * @secure
     */
    fdoConfigureDevice: (guid: string, body: FdoDeviceConfigurePayload, params: RequestParams = {}) =>
      this.request<FdoConfigureDeviceData, void>({
        path: `/fdo/configure/${guid}`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List all known FDO vouchers **Access policy**: administrator
     *
     * @tags intel
     * @name FdoListAll
     * @summary List all known FDO vouchers
     * @request GET:/fdo/list
     * @secure
     */
    fdoListAll: (params: RequestParams = {}) =>
      this.request<FdoListAllData, void>({
        path: `/fdo/list`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description retrieves all FDO profiles **Access policy**: administrator
     *
     * @tags intel
     * @name FdoProfileList
     * @summary retrieves all FDO profiles
     * @request GET:/fdo/profiles
     * @secure
     */
    fdoProfileList: (params: RequestParams = {}) =>
      this.request<FdoProfileListData, void>({
        path: `/fdo/profiles`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description creates a new FDO Profile **Access policy**: administrator
     *
     * @tags intel
     * @name CreateProfile
     * @summary creates a new FDO Profile
     * @request POST:/fdo/profiles
     * @secure
     */
    createProfile: (params: RequestParams = {}) =>
      this.request<CreateProfileData, void>({
        path: `/fdo/profiles`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description deletes a FDO Profile **Access policy**: administrator
     *
     * @tags intel
     * @name DeleteProfile
     * @summary deletes a FDO Profile
     * @request DELETE:/fdo/profiles/{id}
     * @secure
     */
    deleteProfile: (id: string, params: RequestParams = {}) =>
      this.request<DeleteProfileData, void>({
        path: `/fdo/profiles/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description retrieves a given FDO profile information and content **Access policy**: administrator
     *
     * @tags intel
     * @name FdoProfileInspect
     * @summary retrieves a given FDO profile information and content
     * @request GET:/fdo/profiles/{id}
     * @secure
     */
    fdoProfileInspect: (id: string, params: RequestParams = {}) =>
      this.request<FdoProfileInspectData, void>({
        path: `/fdo/profiles/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description updates an existing FDO Profile **Access policy**: administrator
     *
     * @tags intel
     * @name UpdateProfile
     * @summary updates an existing FDO Profile
     * @request PUT:/fdo/profiles/{id}
     * @secure
     */
    updateProfile: (id: string, params: RequestParams = {}) =>
      this.request<UpdateProfileData, void>({
        path: `/fdo/profiles/${id}`,
        method: "PUT",
        secure: true,
        ...params,
      }),

    /**
     * @description duplicated an existing FDO Profile **Access policy**: administrator
     *
     * @tags intel
     * @name Duplicate
     * @summary duplicated an existing FDO Profile
     * @request POST:/fdo/profiles/{id}/duplicate
     * @secure
     */
    duplicate: (id: string, params: RequestParams = {}) =>
      this.request<DuplicateData, void>({
        path: `/fdo/profiles/${id}/duplicate`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description register an FDO device **Access policy**: administrator
     *
     * @tags intel
     * @name FdoRegisterDevice
     * @summary register an FDO device
     * @request POST:/fdo/register
     * @secure
     */
    fdoRegisterDevice: (params: RequestParams = {}) =>
      this.request<FdoRegisterDeviceData, void>({
        path: `/fdo/register`,
        method: "POST",
        secure: true,
        ...params,
      }),
  };
  gitops = {
    /**
     * @description Search the file path from the git repository based on partial or completed filename **Access policy**: authenticated
     *
     * @tags gitops
     * @name GitOperationRepoFilesSearch
     * @summary Search the file path from a git repository files with specified extensions
     * @request POST:/gitops/repo/files/search
     * @secure
     */
    gitOperationRepoFilesSearch: (
      query: GitOperationRepoFilesSearchParams,
      body: GitopsRepositoryFileSearchPayload,
      params: RequestParams = {},
    ) =>
      this.request<GitOperationRepoFilesSearchData, void>({
        path: `/gitops/repo/files/search`,
        method: "POST",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List all the refs of a git repository Will return all refs of a git repository **Access policy**: authenticated
     *
     * @tags gitops
     * @name GitOperationRepoRefs
     * @summary List the refs of a git repository
     * @request POST:/gitops/repo/refs
     * @secure
     */
    gitOperationRepoRefs: (
      query: GitOperationRepoRefsParams,
      body: GitopsRepositoryReferenceListPayload,
      params: RequestParams = {},
    ) =>
      this.request<GitOperationRepoRefsData, void>({
        path: `/gitops/repo/refs`,
        method: "POST",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  kubernetes = {
    /**
     * @description Update Pod Security Rule within k8s cluster **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name UpdateK8SPodSecurityRule
     * @summary Update Pod Security Rule within k8s cluster
     * @request PUT:/kubernetes/{endpointId}/opa
     * @secure
     */
    updateK8SPodSecurityRule: (id: number, endpointId: string, params: RequestParams = {}) =>
      this.request<UpdateK8SPodSecurityRuleData, void>({
        path: `/kubernetes/${endpointId}/opa`,
        method: "PUT",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Gets a list of Kubernetes deployments, statefulsets and daemonsets **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name GetKubernetesApplications
     * @summary gets a list of Kubernetes applications
     * @request GET:/kubernetes/{id}/namespaces/{namespace}/applications
     * @secure
     */
    getKubernetesApplications: (
      { id, namespace, ...query }: GetKubernetesApplicationsParams,
      params: RequestParams = {},
    ) =>
      this.request<GetKubernetesApplicationsData, void>({
        path: `/kubernetes/${id}/namespaces/${namespace}/applications`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Gets a Kubernetes deployment, statefulset and daemonset application details **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name GetKubernetesApplication
     * @summary gets a Kubernetes application
     * @request GET:/kubernetes/{id}/namespaces/{namespace}/applications/{kind}/{name}
     * @secure
     */
    getKubernetesApplication: (
      { id, namespace, kind, name, ...query }: GetKubernetesApplicationParams,
      params: RequestParams = {},
    ) =>
      this.request<GetKubernetesApplicationData, void>({
        path: `/kubernetes/${id}/namespaces/${namespace}/applications/${kind}/${name}`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Toggle the system state for a namespace **Access policy**: administrator or environment(endpoint) admin
     *
     * @tags kubernetes
     * @name KubernetesNamespacesToggleSystem
     * @summary Toggle the system state for a namespace
     * @request PUT:/kubernetes/{id}/namespaces/{namespace}/system
     * @secure
     */
    kubernetesNamespacesToggleSystem: (
      id: number,
      namespace: string,
      body: KubernetesNamespacesToggleSystemPayload,
      params: RequestParams = {},
    ) =>
      this.request<KubernetesNamespacesToggleSystemData, void>({
        path: `/kubernetes/${id}/namespaces/${namespace}/system`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Get CPU and memory limits of all nodes within k8s cluster **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name GetKubernetesNodesLimits
     * @summary Get CPU and memory limits of all nodes within k8s cluster
     * @request GET:/kubernetes/{id}/nodes_limits
     * @secure
     */
    getKubernetesNodesLimits: (id: number, params: RequestParams = {}) =>
      this.request<GetKubernetesNodesLimitsData, void>({
        path: `/kubernetes/${id}/nodes_limits`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Get Pod Security Rule within k8s cluster **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name GetKubernetesPodSecurityRule
     * @summary Get Pod Security Rule within k8s cluster, if not found, the frontend will create a default
     * @request GET:/kubernetes/{id}/opa
     * @secure
     */
    getKubernetesPodSecurityRule: (id: number, params: RequestParams = {}) =>
      this.request<GetKubernetesPodSecurityRuleData, void>({
        path: `/kubernetes/${id}/opa`,
        method: "GET",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Check if RBAC is enabled in the current Kubernetes cluster. **Access policy**: administrator
     *
     * @tags rbac_enabled
     * @name IsRbacEnabled
     * @summary Check if RBAC is enabled
     * @request GET:/kubernetes/{id}/rbac_enabled
     * @secure
     */
    isRbacEnabled: (id: number, params: RequestParams = {}) =>
      this.request<IsRbacEnabledData, void>({
        path: `/kubernetes/${id}/rbac_enabled`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Generates kubeconfig file enabling client communication with k8s api server **Access policy**: authenticated
     *
     * @tags kubernetes
     * @name GetKubernetesConfig
     * @summary Generates kubeconfig file enabling client communication with k8s api server
     * @request GET:/kubernetes/config
     * @secure
     */
    getKubernetesConfig: (query: GetKubernetesConfigParams, params: RequestParams = {}) =>
      this.request<GetKubernetesConfigData, void>({
        path: `/kubernetes/config`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  ldap = {
    /**
     * @description Fetch LDAP admin groups from LDAP server based on AdminGroupSearchSettings **Access policy**: administrator
     *
     * @tags ldap
     * @name LdapAdminGroups
     * @summary Fetch LDAP admin groups
     * @request POST:/ldap/admin-groups
     * @secure
     */
    ldapAdminGroups: (body: LdapAdminGroupsPayload, params: RequestParams = {}) =>
      this.request<LdapAdminGroupsData, void>({
        path: `/ldap/admin-groups`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Test LDAP connectivity using LDAP details **Access policy**: administrator
     *
     * @tags ldap
     * @name LdapCheck
     * @summary Test LDAP connectivity
     * @request POST:/ldap/check
     * @secure
     */
    ldapCheck: (body: LdapCheckPayload, params: RequestParams = {}) =>
      this.request<LdapCheckData, void>({
        path: `/ldap/check`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags ldap
     * @name LdapGroups
     * @summary Search LDAP Groups
     * @request POST:/ldap/groups
     * @secure
     */
    ldapGroups: (body: LdapGroupsPayload, params: RequestParams = {}) =>
      this.request<LdapGroupsData, void>({
        path: `/ldap/groups`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags ldap
     * @name LdapTestLogin
     * @summary Test Login to ldap server
     * @request POST:/ldap/test
     * @secure
     */
    ldapTestLogin: (body: LdapTestLoginPayload, params: RequestParams = {}) =>
      this.request<LdapTestLoginData, void>({
        path: `/ldap/test`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags ldap
     * @name LdapUsers
     * @summary Search LDAP Users
     * @request POST:/ldap/users
     * @secure
     */
    ldapUsers: (body: LdapUsersPayload, params: RequestParams = {}) =>
      this.request<LdapUsersData, void>({
        path: `/ldap/users`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  licenses = {
    /**
     * @description **Access policy**: administrator
     *
     * @tags license
     * @name LicensesList
     * @summary fetches the list of licenses on Portainer
     * @request GET:/licenses
     * @secure
     */
    licensesList: (params: RequestParams = {}) =>
      this.request<LicensesListData, any>({
        path: `/licenses`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags license
     * @name LicensesAttach
     * @summary attaches a list of licenses to Portainer
     * @request POST:/licenses/add
     * @secure
     */
    licensesAttach: (query: LicensesAttachParams, body: LicensesAttachPayload, params: RequestParams = {}) =>
      this.request<LicensesAttachData, any>({
        path: `/licenses/add`,
        method: "POST",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags license
     * @name LicensesInfo
     * @summary summarizes licenses on Portainer
     * @request GET:/licenses/info
     * @secure
     */
    licensesInfo: (params: RequestParams = {}) =>
      this.request<LicensesInfoData, any>({
        path: `/licenses/info`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags license
     * @name LicensesDelete
     * @summary delete license from portainer instance
     * @request POST:/licenses/remove
     * @secure
     */
    licensesDelete: (body: LicensesDeletePayload, params: RequestParams = {}) =>
      this.request<LicensesDeleteData, any>({
        path: `/licenses/remove`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  motd = {
    /**
     * @description **Access policy**: restricted
     *
     * @tags motd
     * @name Motd
     * @summary fetches the message of the day
     * @request GET:/motd
     * @secure
     */
    motd: (params: RequestParams = {}) =>
      this.request<MotdData, any>({
        path: `/motd`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  nomad = {
    /**
     * @description Allocation ID, namespace and task name params are required **Access policy**: administrator
     *
     * @tags nomad
     * @name GetTaskEvents
     * @summary Retrieve events for a nomad task
     * @request GET:/nomad/endpoints/{endpointID}/allocation/{id}/events
     * @secure
     */
    getTaskEvents: (endpointId: string, id: string, params: RequestParams = {}) =>
      this.request<GetTaskEventsData, void>({
        path: `/nomad/endpoints/${endpointId}/allocation/${id}/events`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Allocation ID, namespace, task name and refresh params are required **Access policy**: administrator
     *
     * @tags nomad
     * @name GetTaskLogs
     * @summary Retrieve logs for a nomad task
     * @request GET:/nomad/endpoints/{endpointID}/allocation/{id}/logs
     * @secure
     */
    getTaskLogs: (endpointId: string, id: string, params: RequestParams = {}) =>
      this.request<GetTaskLogsData, void>({
        path: `/nomad/endpoints/${endpointId}/allocation/${id}/logs`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated users
     *
     * @tags nomad
     * @name GetDashboard
     * @summary get basic Nomad information for dashboard
     * @request GET:/nomad/endpoints/{endpointID}/dashboard
     * @secure
     */
    getDashboard: (endpointId: string, params: RequestParams = {}) =>
      this.request<GetDashboardData, void>({
        path: `/nomad/endpoints/${endpointId}/dashboard`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description namespace param is required **Access policy**: authenticated users
     *
     * @tags nomad
     * @name ListJobs
     * @summary List jobs
     * @request GET:/nomad/endpoints/{endpointID}/jobs
     * @secure
     */
    listJobs: (endpointId: string, params: RequestParams = {}) =>
      this.request<ListJobsData, void>({
        path: `/nomad/endpoints/${endpointId}/jobs`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Job ID and namespace params are required **Access policy**: administrator
     *
     * @tags nomad
     * @name DeleteJob
     * @summary Delete a job
     * @request DELETE:/nomad/endpoints/{endpointID}/jobs/{id}
     * @secure
     */
    deleteJob: (endpointId: string, id: string, params: RequestParams = {}) =>
      this.request<DeleteJobData, void>({
        path: `/nomad/endpoints/${endpointId}/jobs/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated users
     *
     * @tags nomad
     * @name GetLeader
     * @summary returns the address of the current leader in the region
     * @request GET:/nomad/endpoints/{endpointID}/leader
     * @secure
     */
    getLeader: (endpointId: string, params: RequestParams = {}) =>
      this.request<GetLeaderData, void>({
        path: `/nomad/endpoints/${endpointId}/leader`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  openAmt = {
    /**
     * @description Enable Portainer's OpenAMT capabilities **Access policy**: administrator
     *
     * @tags intel
     * @name OpenAmtConfigure
     * @summary Enable Portainer's OpenAMT capabilities
     * @request POST:/open_amt
     * @secure
     */
    openAmtConfigure: (body: OpenamtOpenAMTConfigurePayload, params: RequestParams = {}) =>
      this.request<OpenAmtConfigureData, void>({
        path: `/open_amt`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Activate OpenAMT device and associate to agent endpoint **Access policy**: administrator
     *
     * @tags intel
     * @name OpenAmtActivate
     * @summary Activate OpenAMT device and associate to agent endpoint
     * @request POST:/open_amt/{id}/activate
     * @secure
     */
    openAmtActivate: (id: number, params: RequestParams = {}) =>
      this.request<OpenAmtActivateData, void>({
        path: `/open_amt/${id}/activate`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description Fetch OpenAMT managed devices information for endpoint **Access policy**: administrator
     *
     * @tags intel
     * @name OpenAmtDevices
     * @summary Fetch OpenAMT managed devices information for endpoint
     * @request GET:/open_amt/{id}/devices
     * @secure
     */
    openAmtDevices: (id: number, params: RequestParams = {}) =>
      this.request<OpenAmtDevicesData, void>({
        path: `/open_amt/${id}/devices`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Execute out of band action on an AMT managed device **Access policy**: administrator
     *
     * @tags intel
     * @name DeviceAction
     * @summary Execute out of band action on an AMT managed device
     * @request POST:/open_amt/{id}/devices/{deviceId}/action
     * @secure
     */
    deviceAction: (id: string, deviceId: string, body: OpenamtDeviceActionPayload, params: RequestParams = {}) =>
      this.request<DeviceActionData, void>({
        path: `/open_amt/${id}/devices/${deviceId}/action`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Enable features on an AMT managed device **Access policy**: administrator
     *
     * @tags intel
     * @name DeviceFeatures
     * @summary Enable features on an AMT managed device
     * @request POST:/open_amt/{id}/devices_features/{deviceId}
     * @secure
     */
    deviceFeatures: (id: string, deviceId: string, body: OpenamtDeviceFeaturesPayload, params: RequestParams = {}) =>
      this.request<DeviceFeaturesData, void>({
        path: `/open_amt/${id}/devices_features/${deviceId}`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Request OpenAMT info from a node **Access policy**: administrator
     *
     * @tags intel
     * @name OpenAmtHostInfo
     * @summary Request OpenAMT info from a node
     * @request GET:/open_amt/{id}/info
     * @secure
     */
    openAmtHostInfo: (id: string, params: RequestParams = {}) =>
      this.request<OpenAmtHostInfoData, void>({
        path: `/open_amt/${id}/info`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  registries = {
    /**
     * @description List all registries based on the current user authorizations. Will return all registries if using an administrator account otherwise it will only return authorized registries. **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryList
     * @summary List Registries
     * @request GET:/registries
     * @secure
     */
    registryList: (params: RequestParams = {}) =>
      this.request<RegistryListData, void>({
        path: `/registries`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new registry. **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryCreate
     * @summary Create a new registry
     * @request POST:/registries
     * @secure
     */
    registryCreate: (body: RegistriesRegistryCreatePayload, params: RequestParams = {}) =>
      this.request<RegistryCreateData, void>({
        path: `/registries`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a registry **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryDelete
     * @summary Remove a registry
     * @request DELETE:/registries/{id}
     * @secure
     */
    registryDelete: (id: number, params: RequestParams = {}) =>
      this.request<RegistryDeleteData, void>({
        path: `/registries/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about a registry. **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryInspect
     * @summary Inspect a registry
     * @request GET:/registries/{id}
     * @secure
     */
    registryInspect: (id: number, params: RequestParams = {}) =>
      this.request<RegistryInspectData, void>({
        path: `/registries/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a registry **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryUpdate
     * @summary Update a registry
     * @request PUT:/registries/{id}
     * @secure
     */
    registryUpdate: (id: number, body: RegistriesRegistryUpdatePayload, params: RequestParams = {}) =>
      this.request<RegistryUpdateData, void>({
        path: `/registries/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Configures a registry. **Access policy**: restricted
     *
     * @tags registries
     * @name RegistryConfigure
     * @summary Configures a registry
     * @request POST:/registries/{id}/configure
     * @secure
     */
    registryConfigure: (id: number, body: RegistriesRegistryConfigurePayload, params: RequestParams = {}) =>
      this.request<RegistryConfigureData, void>({
        path: `/registries/${id}/configure`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Delete ECR repository. **Access policy**: restricted
     *
     * @tags registries
     * @name EcrDeleteRepository
     * @summary Delete ECR repository
     * @request DELETE:/registries/{id}/ecr/repositories/{repositoryName}
     * @secure
     */
    ecrDeleteRepository: (id: number, repositoryName: string, params: RequestParams = {}) =>
      this.request<EcrDeleteRepositoryData, void>({
        path: `/registries/${id}/ecr/repositories/${repositoryName}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Delete tags for a given ECR repository **Access policy**: restricted
     *
     * @tags registries
     * @name EcrDeleteTags
     * @summary Delete tags
     * @request DELETE:/registries/{id}/ecr/repositories/{repositoryName}/tags
     * @secure
     */
    ecrDeleteTags: (
      id: number,
      repositoryName: string,
      body: RegistriesDeleteTagsPayload,
      params: RequestParams = {},
    ) =>
      this.request<EcrDeleteTagsData, void>({
        path: `/registries/${id}/ecr/repositories/${repositoryName}/tags`,
        method: "DELETE",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  resourceControls = {
    /**
     * @description Create a new resource control to restrict access to a Docker resource. **Access policy**: administrator
     *
     * @tags resource_controls
     * @name ResourceControlCreate
     * @summary Create a new resource control
     * @request POST:/resource_controls
     * @secure
     */
    resourceControlCreate: (body: ResourcecontrolsResourceControlCreatePayload, params: RequestParams = {}) =>
      this.request<ResourceControlCreateData, void>({
        path: `/resource_controls`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a resource control. **Access policy**: administrator
     *
     * @tags resource_controls
     * @name ResourceControlDelete
     * @summary Remove a resource control
     * @request DELETE:/resource_controls/{id}
     * @secure
     */
    resourceControlDelete: (id: number, params: RequestParams = {}) =>
      this.request<ResourceControlDeleteData, void>({
        path: `/resource_controls/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a resource control **Access policy**: authenticated
     *
     * @tags resource_controls
     * @name ResourceControlUpdate
     * @summary Update a resource control
     * @request PUT:/resource_controls/{id}
     * @secure
     */
    resourceControlUpdate: (
      id: number,
      body: ResourcecontrolsResourceControlUpdatePayload,
      params: RequestParams = {},
    ) =>
      this.request<ResourceControlUpdateData, void>({
        path: `/resource_controls/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  restore = {
    /**
     * @description Triggers a system restore using provided backup file **Access policy**: public
     *
     * @tags backup
     * @name Restore
     * @summary Triggers a system restore using provided backup file
     * @request POST:/restore
     */
    restore: (restorePayload: BackupRestorePayload, params: RequestParams = {}) =>
      this.request<RestoreData, void>({
        path: `/restore`,
        method: "POST",
        body: restorePayload,
        type: ContentType.Json,
        ...params,
      }),
  };
  roles = {
    /**
     * @description List all roles available for use **Access policy**: administrator
     *
     * @tags roles
     * @name RoleList
     * @summary List roles
     * @request GET:/roles
     * @secure
     */
    roleList: (params: RequestParams = {}) =>
      this.request<RoleListData, void>({
        path: `/roles`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  settings = {
    /**
     * @description Retrieve Portainer settings. **Access policy**: administrator
     *
     * @tags settings
     * @name SettingsInspect
     * @summary Retrieve Portainer settings
     * @request GET:/settings
     * @secure
     */
    settingsInspect: (params: RequestParams = {}) =>
      this.request<SettingsInspectData, void>({
        path: `/settings`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update Portainer settings. **Access policy**: administrator
     *
     * @tags settings
     * @name SettingsUpdate
     * @summary Update Portainer settings
     * @request PUT:/settings
     * @secure
     */
    settingsUpdate: (body: SettingsSettingsUpdatePayload, params: RequestParams = {}) =>
      this.request<SettingsUpdateData, void>({
        path: `/settings`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Retrieve Portainer experimental settings. **Access policy**: authenticated
     *
     * @tags settings
     * @name SettingsExperimentalInspect
     * @summary Retrieve Portainer experimental settings
     * @request GET:/settings/experimental
     * @secure
     */
    settingsExperimentalInspect: (params: RequestParams = {}) =>
      this.request<SettingsExperimentalInspectData, void>({
        path: `/settings/experimental`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update Portainer experimental settings. **Access policy**: administrator
     *
     * @tags settings
     * @name SettingsExperimentalUpdate
     * @summary Update Portainer experimental settings
     * @request PUT:/settings/experimental
     * @secure
     */
    settingsExperimentalUpdate: (body: SettingsSettingsExperimentalUpdatePayload, params: RequestParams = {}) =>
      this.request<SettingsExperimentalUpdateData, void>({
        path: `/settings/experimental`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Retrieve public settings. Returns a small set of settings that are not reserved to administrators only. **Access policy**: public
     *
     * @tags settings
     * @name SettingsPublic
     * @summary Retrieve Portainer public settings
     * @request GET:/settings/public
     */
    settingsPublic: (params: RequestParams = {}) =>
      this.request<SettingsPublicData, void>({
        path: `/settings/public`,
        method: "GET",
        ...params,
      }),
  };
  sshkeygen = {
    /**
     * @description Generate an ssh public / private keypair **Access policy**: authenticated
     *
     * @tags cloud_credentials
     * @name Generate
     * @summary Generate ssh keypair
     * @request POST:/sshkeygen
     * @secure
     */
    generate: (params: RequestParams = {}) =>
      this.request<GenerateData, void>({
        path: `/sshkeygen`,
        method: "POST",
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  ssl = {
    /**
     * @description Retrieve the ssl settings. **Access policy**: administrator
     *
     * @tags ssl
     * @name SslInspect
     * @summary Inspect the ssl settings
     * @request GET:/ssl
     * @secure
     */
    sslInspect: (params: RequestParams = {}) =>
      this.request<SslInspectData, void>({
        path: `/ssl`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update the ssl settings. **Access policy**: administrator
     *
     * @tags ssl
     * @name SslUpdate
     * @summary Update the ssl settings
     * @request PUT:/ssl
     * @secure
     */
    sslUpdate: (body: SslSslUpdatePayload, params: RequestParams = {}) =>
      this.request<SslUpdateData, void>({
        path: `/ssl`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  stacks = {
    /**
     * @description List all stacks based on the current user authorizations. Will return all stacks if using an administrator account otherwise it will only return the list of stacks the user have access to. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackList
     * @summary List stacks
     * @request GET:/stacks
     * @secure
     */
    stackList: (query: StackListParams, params: RequestParams = {}) =>
      this.request<StackListData, void>({
        path: `/stacks`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Deploy a new stack into a Docker environment(endpoint) specified via the environment(endpoint) identifier. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackCreate
     * @summary Deploy a new stack
     * @request POST:/stacks
     * @secure
     */
    stackCreate: (query: StackCreateParams, body_kubernetes_url: StackCreatePayload, params: RequestParams = {}) =>
      this.request<StackCreateData, void>({
        path: `/stacks`,
        method: "POST",
        query: query,
        body: body_kubernetes_url,
        secure: true,
        type: ContentType.FormData,
        ...params,
      }),

    /**
     * @description Remove a stack. **Access policy**: restricted
     *
     * @tags stacks
     * @name StackDelete
     * @summary Remove a stack
     * @request DELETE:/stacks/{id}
     * @secure
     */
    stackDelete: ({ id, ...query }: StackDeleteParams, params: RequestParams = {}) =>
      this.request<StackDeleteData, void>({
        path: `/stacks/${id}`,
        method: "DELETE",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about a stack. **Access policy**: restricted
     *
     * @tags stacks
     * @name StackInspect
     * @summary Inspect a stack
     * @request GET:/stacks/{id}
     * @secure
     */
    stackInspect: (id: number, params: RequestParams = {}) =>
      this.request<StackInspectData, void>({
        path: `/stacks/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a stack, only for file based stacks. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackUpdate
     * @summary Update a stack
     * @request PUT:/stacks/{id}
     * @secure
     */
    stackUpdate: (
      { id, ...query }: StackUpdateParams,
      body: StacksUpdateSwarmStackPayload,
      params: RequestParams = {},
    ) =>
      this.request<StackUpdateData, void>({
        path: `/stacks/${id}`,
        method: "PUT",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: administrator
     *
     * @tags stacks
     * @name StackAssociate
     * @summary Associate an orphaned stack to a new environment(endpoint)
     * @request PUT:/stacks/{id}/associate
     * @secure
     */
    stackAssociate: ({ id, ...query }: StackAssociateParams, params: RequestParams = {}) =>
      this.request<StackAssociateData, void>({
        path: `/stacks/${id}/associate`,
        method: "PUT",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Get Stack file content. **Access policy**: restricted
     *
     * @tags stacks
     * @name StackFileInspect
     * @summary Retrieve the content of the Stack file for the specified stack
     * @request GET:/stacks/{id}/file
     * @secure
     */
    stackFileInspect: (id: number, params: RequestParams = {}) =>
      this.request<StackFileInspectData, void>({
        path: `/stacks/${id}/file`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update the Git settings in a stack, e.g., RepositoryReferenceName and AutoUpdate **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackUpdateGit
     * @summary Update a stack's Git configs
     * @request POST:/stacks/{id}/git
     * @secure
     */
    stackUpdateGit: (
      { id, ...query }: StackUpdateGitParams,
      body: StacksStackGitUpdatePayload,
      params: RequestParams = {},
    ) =>
      this.request<StackUpdateGitData, void>({
        path: `/stacks/${id}/git`,
        method: "POST",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Pull and redeploy a stack via Git **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackGitRedeploy
     * @summary Redeploy a stack
     * @request PUT:/stacks/{id}/git/redeploy
     * @secure
     */
    stackGitRedeploy: (
      { id, ...query }: StackGitRedeployParams,
      body: StacksStackGitRedployPayload,
      params: RequestParams = {},
    ) =>
      this.request<StackGitRedeployData, void>({
        path: `/stacks/${id}/git/redeploy`,
        method: "PUT",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Migrate a stack from an environment(endpoint) to another environment(endpoint). It will re-create the stack inside the target environment(endpoint) before removing the original stack. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackMigrate
     * @summary Migrate a stack to another environment(endpoint)
     * @request POST:/stacks/{id}/migrate
     * @secure
     */
    stackMigrate: ({ id, ...query }: StackMigrateParams, body: StacksStackMigratePayload, params: RequestParams = {}) =>
      this.request<StackMigrateData, void>({
        path: `/stacks/${id}/migrate`,
        method: "POST",
        query: query,
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Starts a stopped Stack. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackStart
     * @summary Starts a stopped Stack
     * @request POST:/stacks/{id}/start
     * @secure
     */
    stackStart: (id: number, params: RequestParams = {}) =>
      this.request<StackStartData, void>({
        path: `/stacks/${id}/start`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description Stops a stopped Stack. **Access policy**: authenticated
     *
     * @tags stacks
     * @name StackStop
     * @summary Stops a stopped Stack
     * @request POST:/stacks/{id}/stop
     * @secure
     */
    stackStop: (id: number, params: RequestParams = {}) =>
      this.request<StackStopData, void>({
        path: `/stacks/${id}/stop`,
        method: "POST",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: public
     *
     * @tags stacks
     * @name WebhookInvoke
     * @summary Webhook for triggering stack updates from git
     * @request POST:/stacks/webhooks/{webhookID}
     */
    webhookInvoke: (webhookId: string, params: RequestParams = {}) =>
      this.request<WebhookInvokeData, void>({
        path: `/stacks/webhooks/${webhookId}`,
        method: "POST",
        ...params,
      }),
  };
  status = {
    /**
     * @description Deprecated: use the `/system/status` endpoint instead. Retrieve Portainer status **Access policy**: public
     *
     * @tags status
     * @name StatusInspect
     * @summary Check Portainer status
     * @request GET:/status
     * @deprecated
     */
    statusInspect: (params: RequestParams = {}) =>
      this.request<StatusInspectData, any>({
        path: `/status`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Deprecated: use the `/system/nodes` endpoint instead. **Access policy**: authenticated
     *
     * @tags status
     * @name StatusNodesCount
     * @summary Retrieve the count of nodes
     * @request GET:/status/nodes
     * @deprecated
     * @secure
     */
    statusNodesCount: (params: RequestParams = {}) =>
      this.request<StatusNodesCountData, void>({
        path: `/status/nodes`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Deprecated: use the `/system/version` endpoint instead. Check if portainer has an update available **Access policy**: authenticated
     *
     * @tags status
     * @name Version
     * @summary Check for portainer updates
     * @request GET:/status/version
     * @deprecated
     * @secure
     */
    version: (params: RequestParams = {}) =>
      this.request<VersionData, any>({
        path: `/status/version`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  system = {
    /**
     * @description **Access policy**: authenticated
     *
     * @tags system
     * @name SystemInfo
     * @summary Retrieve system info
     * @request GET:/system/info
     * @secure
     */
    systemInfo: (params: RequestParams = {}) =>
      this.request<SystemInfoData, void>({
        path: `/system/info`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags system
     * @name SystemNodesCount
     * @summary Retrieve the count of nodes
     * @request GET:/system/nodes
     * @secure
     */
    systemNodesCount: (params: RequestParams = {}) =>
      this.request<SystemNodesCountData, void>({
        path: `/system/nodes`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve Portainer status **Access policy**: public
     *
     * @tags system
     * @name SystemStatus
     * @summary Check Portainer status
     * @request GET:/system/status
     */
    systemStatus: (params: RequestParams = {}) =>
      this.request<SystemStatusData, any>({
        path: `/system/status`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Upgrade Portainer to BE **Access policy**: administrator
     *
     * @tags system
     * @name SystemUpgrade
     * @summary Upgrade Portainer to BE
     * @request POST:/system/upgrade
     */
    systemUpgrade: (params: RequestParams = {}) =>
      this.request<SystemUpgradeData, any>({
        path: `/system/upgrade`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Check if portainer has an update available **Access policy**: authenticated
     *
     * @tags system
     * @name SystemVersion
     * @summary Check for portainer updates
     * @request GET:/system/version
     * @secure
     */
    systemVersion: (params: RequestParams = {}) =>
      this.request<SystemVersionData, any>({
        path: `/system/version`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  tags = {
    /**
     * @description List tags. **Access policy**: authenticated
     *
     * @tags tags
     * @name TagList
     * @summary List tags
     * @request GET:/tags
     * @secure
     */
    tagList: (params: RequestParams = {}) =>
      this.request<TagListData, void>({
        path: `/tags`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new tag. **Access policy**: administrator
     *
     * @tags tags
     * @name TagCreate
     * @summary Create a new tag
     * @request POST:/tags
     * @secure
     */
    tagCreate: (body: TagsTagCreatePayload, params: RequestParams = {}) =>
      this.request<TagCreateData, void>({
        path: `/tags`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a tag. **Access policy**: administrator
     *
     * @tags tags
     * @name TagDelete
     * @summary Remove a tag
     * @request DELETE:/tags/{id}
     * @secure
     */
    tagDelete: (id: number, params: RequestParams = {}) =>
      this.request<TagDeleteData, void>({
        path: `/tags/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),
  };
  teamMemberships = {
    /**
     * @description List team memberships. Access is only available to administrators and team leaders. **Access policy**: administrator
     *
     * @tags team_memberships
     * @name TeamMembershipList
     * @summary List team memberships
     * @request GET:/team_memberships
     * @secure
     */
    teamMembershipList: (params: RequestParams = {}) =>
      this.request<TeamMembershipListData, void>({
        path: `/team_memberships`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new team memberships. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     *
     * @tags team_memberships
     * @name TeamMembershipCreate
     * @summary Create a new team membership
     * @request POST:/team_memberships
     * @secure
     */
    teamMembershipCreate: (body: TeammembershipsTeamMembershipCreatePayload, params: RequestParams = {}) =>
      this.request<TeamMembershipCreateData, void>({
        path: `/team_memberships`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a team membership. Access is only available to administrators leaders of the associated team. **Access policy**: administrator
     *
     * @tags team_memberships
     * @name TeamMembershipDelete
     * @summary Remove a team membership
     * @request DELETE:/team_memberships/{id}
     * @secure
     */
    teamMembershipDelete: (id: number, params: RequestParams = {}) =>
      this.request<TeamMembershipDeleteData, void>({
        path: `/team_memberships/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a team membership. Access is only available to administrators or leaders of the associated team. **Access policy**: administrator or leaders of the associated team
     *
     * @tags team_memberships
     * @name TeamMembershipUpdate
     * @summary Update a team membership
     * @request PUT:/team_memberships/{id}
     * @secure
     */
    teamMembershipUpdate: (id: number, body: TeammembershipsTeamMembershipUpdatePayload, params: RequestParams = {}) =>
      this.request<TeamMembershipUpdateData, void>({
        path: `/team_memberships/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  teams = {
    /**
     * @description List teams. For non-administrator users, will only list the teams they are member of. **Access policy**: restricted
     *
     * @tags teams
     * @name TeamList
     * @summary List teams
     * @request GET:/teams
     * @secure
     */
    teamList: (query: TeamListParams, params: RequestParams = {}) =>
      this.request<TeamListData, void>({
        path: `/teams`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new team. **Access policy**: administrator
     *
     * @tags teams
     * @name TeamCreate
     * @summary Create a new team
     * @request POST:/teams
     * @secure
     */
    teamCreate: (body: TeamsTeamCreatePayload, params: RequestParams = {}) =>
      this.request<TeamCreateData, void>({
        path: `/teams`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a team. **Access policy**: administrator
     *
     * @tags teams
     * @name TeamDelete
     * @summary Remove a team
     * @request DELETE:/teams/{id}
     * @secure
     */
    teamDelete: (id: number, params: RequestParams = {}) =>
      this.request<TeamDeleteData, void>({
        path: `/teams/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about a team. Access is only available for administrator and leaders of that team. **Access policy**: administrator or team leader
     *
     * @tags teams
     * @name TeamInspect
     * @summary Inspect a team
     * @request GET:/teams/{id}
     * @secure
     */
    teamInspect: (id: number, params: RequestParams = {}) =>
      this.request<TeamInspectData, void>({
        path: `/teams/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a team. **Access policy**: administrator
     *
     * @tags teams
     * @name TeamUpdate
     * @summary Update a team
     * @request PUT:/teams/{id}
     * @secure
     */
    teamUpdate: (id: number, body: TeamsTeamUpdatePayload, params: RequestParams = {}) =>
      this.request<TeamUpdateData, void>({
        path: `/teams/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description List team memberships. Access is only available to administrators and team leaders. **Access policy**: restricted
     *
     * @tags team_memberships
     * @name TeamMemberships
     * @summary List team memberships
     * @request GET:/teams/{id}/memberships
     * @secure
     */
    teamMemberships: (id: number, params: RequestParams = {}) =>
      this.request<TeamMembershipsData, void>({
        path: `/teams/${id}/memberships`,
        method: "GET",
        secure: true,
        ...params,
      }),
  };
  templates = {
    /**
     * @description List available templates. **Access policy**: authenticated
     *
     * @tags templates
     * @name TemplateList
     * @summary List available templates
     * @request GET:/templates
     * @secure
     */
    templateList: (params: RequestParams = {}) =>
      this.request<TemplateListData, void>({
        path: `/templates`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Get a template's file **Access policy**: authenticated
     *
     * @tags templates
     * @name TemplateFile
     * @summary Get a template's file
     * @request POST:/templates/file
     * @secure
     */
    templateFile: (body: TemplatesFilePayload, params: RequestParams = {}) =>
      this.request<TemplateFileData, void>({
        path: `/templates/file`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmRepoSearch
     * @summary Search Helm Charts
     * @request GET:/templates/helm
     * @secure
     */
    helmRepoSearch: (query: HelmRepoSearchParams, params: RequestParams = {}) =>
      this.request<HelmRepoSearchData, void>({
        path: `/templates/helm`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags helm
     * @name HelmShow
     * @summary Show Helm Chart Information
     * @request GET:/templates/helm/{command}
     * @secure
     */
    helmShow: ({ command, ...query }: HelmShowParams, params: RequestParams = {}) =>
      this.request<HelmShowData, void>({
        path: `/templates/helm/${command}`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
  upload = {
    /**
     * @description Use this environment(endpoint) to upload TLS files. **Access policy**: administrator
     *
     * @tags upload
     * @name UploadTls
     * @summary Upload TLS files
     * @request POST:/upload/tls/{certificate}
     * @secure
     */
    uploadTls: (certificate: "ca" | "cert" | "key", data: UploadTlsPayload, params: RequestParams = {}) =>
      this.request<UploadTlsData, void>({
        path: `/upload/tls/${certificate}`,
        method: "POST",
        body: data,
        secure: true,
        type: ContentType.FormData,
        ...params,
      }),
  };
  useractivity = {
    /**
     * @description List logs by provided query **Access policy**: admin
     *
     * @tags useractivity
     * @name AuthLogsList
     * @summary List auth activity logs
     * @request GET:/useractivity/authlogs
     * @secure
     */
    authLogsList: (query: AuthLogsListParams, params: RequestParams = {}) =>
      this.request<AuthLogsListData, void>({
        path: `/useractivity/authlogs`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Download auth logs as CSV by provided query **Access policy**: admin
     *
     * @tags useractivity
     * @name AuthLogsCsv
     * @summary Download auth logs as CSV
     * @request GET:/useractivity/authlogs.csv
     * @secure
     */
    authLogsCsv: (query: AuthLogsCsvParams, params: RequestParams = {}) =>
      this.request<AuthLogsCsvData, void>({
        path: `/useractivity/authlogs.csv`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description List logs by provided query **Access policy**: admin
     *
     * @tags useractivity
     * @name LogsList
     * @summary List user activity logs
     * @request GET:/useractivity/logs
     * @secure
     */
    logsList: (query: LogsListParams, params: RequestParams = {}) =>
      this.request<LogsListData, void>({
        path: `/useractivity/logs`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Download user activity logs as CSV by provided query **Access policy**: admin
     *
     * @tags useractivity
     * @name LogsCsv
     * @summary Download user activity logs as CSV
     * @request GET:/useractivity/logs.csv
     * @secure
     */
    logsCsv: (query: LogsCsvParams, params: RequestParams = {}) =>
      this.request<LogsCsvData, void>({
        path: `/useractivity/logs.csv`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),
  };
  users = {
    /**
     * @description List Portainer users. Non-administrator users will only be able to list other non-administrator user accounts. User passwords are filtered out, and should never be accessible. **Access policy**: restricted
     *
     * @tags users
     * @name UserList
     * @summary List users
     * @request GET:/users
     * @secure
     */
    userList: (query: UserListParams, params: RequestParams = {}) =>
      this.request<UserListData, void>({
        path: `/users`,
        method: "GET",
        query: query,
        secure: true,
        ...params,
      }),

    /**
     * @description Create a new Portainer user. Only administrators can create users. **Access policy**: restricted
     *
     * @tags users
     * @name UserCreate
     * @summary Create a new user
     * @request POST:/users
     * @secure
     */
    userCreate: (body: UsersUserCreatePayload, params: RequestParams = {}) =>
      this.request<UserCreateData, void>({
        path: `/users`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a user. **Access policy**: administrator
     *
     * @tags users
     * @name UserDelete
     * @summary Remove a user
     * @request DELETE:/users/{id}
     * @secure
     */
    userDelete: (id: number, params: RequestParams = {}) =>
      this.request<UserDeleteData, void>({
        path: `/users/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieve details about a user. User passwords are filtered out, and should never be accessible. **Access policy**: authenticated
     *
     * @tags users
     * @name UserInspect
     * @summary Inspect a user
     * @request GET:/users/{id}
     * @secure
     */
    userInspect: (id: number, params: RequestParams = {}) =>
      this.request<UserInspectData, void>({
        path: `/users/${id}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update user details. A regular user account can only update his details. **Access policy**: authenticated
     *
     * @tags users
     * @name UserUpdate
     * @summary Update a user
     * @request PUT:/users/{id}
     * @secure
     */
    userUpdate: (id: number, body: UsersUserUpdatePayload, params: RequestParams = {}) =>
      this.request<UserUpdateData, void>({
        path: `/users/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Gets all saved git credentials for a user. Only the calling user can retrieve git credentials **Access policy**: authenticated
     *
     * @tags users
     * @name UserGetGitCredentials
     * @summary Get all saved git credentials for a user
     * @request GET:/users/{id}/gitcredentials
     * @secure
     */
    userGetGitCredentials: (id: number, params: RequestParams = {}) =>
      this.request<UserGetGitCredentialsData, void>({
        path: `/users/${id}/gitcredentials`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Store a Git Credential for a user. Only the calling user can store a git credential for themselves. **Access policy**: restricted
     *
     * @tags users
     * @name UserCreateGitCredential
     * @summary Store a Git Credential for a user
     * @request POST:/users/{id}/gitcredentials
     * @secure
     */
    userCreateGitCredential: (id: number, body: UsersUserGitCredentialCreatePayload, params: RequestParams = {}) =>
      this.request<UserCreateGitCredentialData, void>({
        path: `/users/${id}/gitcredentials`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove a git-credential associated to a user.. Only the calling user can remove git-credential **Access policy**: authenticated
     *
     * @tags users
     * @name UserRemoveGitCredential
     * @summary Remove a git-credential associated to a user
     * @request DELETE:/users/{id}/gitcredentials/{credentialID}
     * @secure
     */
    userRemoveGitCredential: (id: number, credentialId: number, params: RequestParams = {}) =>
      this.request<UserRemoveGitCredentialData, void>({
        path: `/users/${id}/gitcredentials/${credentialId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Gets the specific saved git credential for a user. Only the calling user can retrieve git credential **Access policy**: authenticated
     *
     * @tags users
     * @name UserGetGitCredential
     * @summary Get the specific saved git credential for a user
     * @request GET:/users/{id}/gitcredentials/{credentialID}
     * @secure
     */
    userGetGitCredential: (id: number, credentialId: number, params: RequestParams = {}) =>
      this.request<UserGetGitCredentialData, void>({
        path: `/users/${id}/gitcredentials/${credentialId}`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update a git-credential associated to a user.. Only the calling user can update git-credential **Access policy**: authenticated
     *
     * @tags users
     * @name UserUpdateGitCredential
     * @summary Update a git-credential associated to a user
     * @request PUT:/users/{id}/gitcredentials/{credentialID}
     * @secure
     */
    userUpdateGitCredential: (id: number, credentialId: number, params: RequestParams = {}) =>
      this.request<UserUpdateGitCredentialData, void>({
        path: `/users/${id}/gitcredentials/${credentialId}`,
        method: "PUT",
        secure: true,
        ...params,
      }),

    /**
     * @description Inspect a user memberships. **Access policy**: restricted
     *
     * @tags users
     * @name UserMembershipsInspect
     * @summary Inspect a user memberships
     * @request GET:/users/{id}/memberships
     * @secure
     */
    userMembershipsInspect: (id: number, params: RequestParams = {}) =>
      this.request<UserMembershipsInspectData, void>({
        path: `/users/${id}/memberships`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Retrieves user's role authorizations of all namespaces in all k8s environments(endpoints) **Access policy**: restricted
     *
     * @tags users
     * @name UserNamespaces
     * @summary Retrieves all k8s namespaces for an user
     * @request GET:/users/{id}/namespaces
     * @secure
     */
    userNamespaces: (id: number, params: RequestParams = {}) =>
      this.request<UserNamespacesData, void>({
        path: `/users/${id}/namespaces`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Update the OpenAI API key and OpenAI model associated to a user. Requires the OpenAI experimental feature setting to be enabled. This configuration will be used when interacting with the OpenAI chat. Only an administrator user or the user itself can update the OpenAI API key. **Access policy**: restricted
     *
     * @tags users
     * @name UserUpdateOpenAiConfig
     * @summary Update the OpenAI API configuration associated to a user.
     * @request PUT:/users/{id}/openai
     * @secure
     */
    userUpdateOpenAiConfig: (id: number, body: UsersUserUpdateOpenAIConfigPayload, params: RequestParams = {}) =>
      this.request<UserUpdateOpenAiConfigData, void>({
        path: `/users/${id}/openai`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Update password for the specified user. **Access policy**: authenticated
     *
     * @tags users
     * @name UserUpdatePassword
     * @summary Update password for a user
     * @request PUT:/users/{id}/passwd
     * @secure
     */
    userUpdatePassword: (id: number, body: UsersUserUpdatePasswordPayload, params: RequestParams = {}) =>
      this.request<UserUpdatePasswordData, void>({
        path: `/users/${id}/passwd`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Gets all API keys for a user. Only the calling user or admin can retrieve api-keys. **Access policy**: authenticated
     *
     * @tags users
     * @name UserGetApiKeys
     * @summary Get all API keys for a user
     * @request GET:/users/{id}/tokens
     * @secure
     */
    userGetApiKeys: (id: number, params: RequestParams = {}) =>
      this.request<UserGetApiKeysData, void>({
        path: `/users/${id}/tokens`,
        method: "GET",
        secure: true,
        ...params,
      }),

    /**
     * @description Generates an API key for a user. Only the calling user can generate a token for themselves. **Access policy**: restricted
     *
     * @tags users
     * @name UserGenerateApiKey
     * @summary Generate an API key for a user
     * @request POST:/users/{id}/tokens
     * @secure
     */
    userGenerateApiKey: (id: number, body: UsersUserAccessTokenCreatePayload, params: RequestParams = {}) =>
      this.request<UserGenerateApiKeyData, void>({
        path: `/users/${id}/tokens`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Remove an api-key associated to a user.. Only the calling user or admin can remove api-key. **Access policy**: authenticated
     *
     * @tags users
     * @name UserRemoveApiKey
     * @summary Remove an api-key associated to a user
     * @request DELETE:/users/{id}/tokens/{keyID}
     * @secure
     */
    userRemoveApiKey: (id: number, keyId: number, params: RequestParams = {}) =>
      this.request<UserRemoveApiKeyData, void>({
        path: `/users/${id}/tokens/${keyId}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description Check if an administrator account exists in the database. **Access policy**: public
     *
     * @tags users
     * @name UserAdminCheck
     * @summary Check administrator account existence
     * @request GET:/users/admin/check
     */
    userAdminCheck: (params: RequestParams = {}) =>
      this.request<UserAdminCheckData, void>({
        path: `/users/admin/check`,
        method: "GET",
        ...params,
      }),

    /**
     * @description Initialize the 'admin' user account. **Access policy**: public
     *
     * @tags users
     * @name UserAdminInit
     * @summary Initialize administrator account
     * @request POST:/users/admin/init
     */
    userAdminInit: (body: UsersAdminInitPayload, params: RequestParams = {}) =>
      this.request<UserAdminInitData, void>({
        path: `/users/admin/init`,
        method: "POST",
        body: body,
        type: ContentType.Json,
        ...params,
      }),
  };
  webhooks = {
    /**
     * @description **Access policy**: authenticated
     *
     * @tags webhooks
     * @name WebhooksList
     * @summary List webhooks
     * @request GET:/webhooks
     * @secure
     */
    webhooksList: (query: WebhooksListParams, params: RequestParams = {}) =>
      this.request<WebhooksListData, void>({
        path: `/webhooks`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags webhooks
     * @name WebhooksCreate
     * @summary Create a webhook
     * @request POST:/webhooks
     * @secure
     */
    webhooksCreate: (body: WebhooksWebhookCreatePayload, params: RequestParams = {}) =>
      this.request<WebhooksCreateData, void>({
        path: `/webhooks`,
        method: "POST",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags webhooks
     * @name WebhooksDelete
     * @summary Delete a webhook
     * @request DELETE:/webhooks/{id}
     * @secure
     */
    webhooksDelete: (id: number, params: RequestParams = {}) =>
      this.request<WebhooksDeleteData, void>({
        path: `/webhooks/${id}`,
        method: "DELETE",
        secure: true,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags webhooks
     * @name WebhooksUpdate
     * @summary Update a webhook
     * @request PUT:/webhooks/{id}
     * @secure
     */
    webhooksUpdate: (id: string, body: WebhooksWebhookUpdatePayload, params: RequestParams = {}) =>
      this.request<WebhooksUpdateData, void>({
        path: `/webhooks/${id}`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description **Access policy**: authenticated
     *
     * @tags webhooks
     * @name ReassignUpdate
     * @summary Reassign a webhook to another resource
     * @request PUT:/webhooks/{id}/reassign
     * @secure
     */
    reassignUpdate: (id: string, body: WebhooksWebhookReassignPayload, params: RequestParams = {}) =>
      this.request<ReassignUpdateData, void>({
        path: `/webhooks/${id}/reassign`,
        method: "PUT",
        body: body,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Acts on a passed in token UUID to restart the docker service **Access policy**: public
     *
     * @tags webhooks
     * @name WebhooksCreate2
     * @summary Execute a webhook
     * @request POST:/webhooks/{token}
     * @originalName webhooksCreate
     * @duplicate
     */
    webhooksCreate2: (token: string, params: RequestParams = {}) =>
      this.request<WebhooksCreate2Data, void>({
        path: `/webhooks/${token}`,
        method: "POST",
        ...params,
      }),
  };
  websocket = {
    /**
     * @description If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an AttachStart operation HTTP request will be created and hijacked. **Access policy**: authenticated
     *
     * @tags websocket
     * @name AttachList
     * @summary Attach a websocket
     * @request GET:/websocket/attach
     * @secure
     */
    attachList: (query: AttachListParams, params: RequestParams = {}) =>
      this.request<AttachListData, void>({
        path: `/websocket/attach`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description If the nodeName query parameter is present, the request will be proxied to the underlying agent environment(endpoint). If the nodeName query parameter is not specified, the request will be upgraded to the websocket protocol and an ExecStart operation HTTP request will be created and hijacked.
     *
     * @tags websocket
     * @name ExecList
     * @summary Execute a websocket
     * @request GET:/websocket/exec
     * @secure
     */
    execList: (query: ExecListParams, params: RequestParams = {}) =>
      this.request<ExecListData, void>({
        path: `/websocket/exec`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description The request will be upgraded to the websocket protocol. The request will proxy input from the client to the pod via long-lived websocket connection. **Access policy**: authenticated
     *
     * @tags websocket
     * @name KubernetesShellList
     * @summary Execute a websocket on kubectl shell pod
     * @request GET:/websocket/kubernetes-shell
     * @secure
     */
    kubernetesShellList: (query: KubernetesShellListParams, params: RequestParams = {}) =>
      this.request<KubernetesShellListData, void>({
        path: `/websocket/kubernetes-shell`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description The request will be upgraded to the websocket protocol. **Access policy**: authenticated
     *
     * @tags websocket
     * @name GetWebsocket
     * @summary Execute a websocket on pod
     * @request GET:/websocket/pod
     * @secure
     */
    getWebsocket: (query: GetWebsocketParams, params: RequestParams = {}) =>
      this.request<GetWebsocketData, void>({
        path: `/websocket/pod`,
        method: "GET",
        query: query,
        secure: true,
        type: ContentType.Json,
        ...params,
      }),
  };
}
